INFO [session.py]: Pytest detected. Using in-memory SQLite for tests.
DEBUG [session.py]: Final DATABASE_URL for sync engine: sqlite:///:memory:
DEBUG [session.py]: Final ASYNC_DATABASE_URL for async engine: sqlite+aiosqlite:///:memory:
============================= test session starts ==============================
platform darwin -- Python 3.9.6, pytest-8.3.5, pluggy-1.6.0
rootdir: /Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf
configfile: pytest.ini
plugins: anyio-4.9.0, asyncio-1.0.0
asyncio: mode=strict, asyncio_default_fixture_loop_scope=session, asyncio_default_test_loop_scope=function
collected 17 items

backend/app/tests/api/test_applications_api.py DEBUG [conftest.py create_test_tables]: All tables created.
DEBUG [conftest.py create_test_tables - SYNC]: Table 'people' not found.
DEBUG [conftest.py create_test_tables - SYNC]: Schema for table 'organizations':
  SYNC Column: id, Type: CHAR(32)
  SYNC Column: name, Type: VARCHAR(255)
  SYNC Column: description, Type: TEXT
  SYNC Column: industry, Type: VARCHAR(100)
  SYNC Column: isActive, Type: BOOLEAN
  SYNC Column: createdAt, Type: DATETIME
  SYNC Column: updatedAt, Type: DATETIME
DEBUG [conftest.py create_test_tables - SYNC]: Schema for table 'roles':
  SYNC Column: id, Type: CHAR(32)
  SYNC Column: name, Type: VARCHAR(50)
  SYNC Column: description, Type: TEXT
  SYNC Column: organization_id, Type: CHAR(32)
  SYNC Column: createdAt, Type: DATETIME
  SYNC Column: updatedAt, Type: DATETIME
DEBUG [conftest.py create_test_tables - SYNC]: Schema for table 'permissions':
  SYNC Column: id, Type: CHAR(32)
  SYNC Column: name, Type: VARCHAR(255)
  SYNC Column: description, Type: TEXT
  SYNC Column: createdAt, Type: DATETIME
  SYNC Column: updatedAt, Type: DATETIME
DEBUG [conftest.py create_test_tables - SYNC]: Table 'people_roles' not found.
DEBUG [conftest.py create_test_tables - SYNC]: Schema for table 'role_permissions':
  SYNC Column: role_id, Type: CHAR(32)
  SYNC Column: permission_id, Type: CHAR(32)
DEBUG [conftest.py create_test_tables - SYNC]: Schema for table 'applications':
  SYNC Column: id, Type: CHAR(32)
  SYNC Column: name, Type: VARCHAR(255)
  SYNC Column: description, Type: TEXT
  SYNC Column: type, Type: VARCHAR(5)
    SYNC 'applications.type' column found. Type: VARCHAR(5)
  SYNC Column: hostedOn, Type: VARCHAR(255)
  SYNC Column: workarounds, Type: TEXT
  SYNC Column: derivedRTO, Type: VARCHAR(50)
  SYNC Column: status, Type: VARCHAR(8)
  SYNC Column: organizationId, Type: CHAR(32)
  SYNC Column: appOwnerId, Type: CHAR(32)
DEBUG [conftest.py create_test_tables_async]: Creating async tables...
DEBUG [conftest.py create_test_tables_async]: Async tables created.
DEBUG [conftest.py async_db_session]: Added default async organization: Default Test Organization Async
DEBUG [conftest.py async_db_session]: Added default async user: default.async.user@example.com
DEBUG [conftest.py async_db_session]: Committed default async org/user for session 4397827312.
Unexpected error in create_application: (sqlite3.OperationalError) no such table: organizations
[SQL: SELECT organizations.id, organizations.name, organizations.description, organizations.industry, organizations."isActive", organizations."createdAt", organizations."updatedAt" 
FROM organizations 
WHERE organizations.id = ?]
[parameters: ('00000000000000000000000000000001',)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
FDEBUG [conftest.py async_db_session]: Committed default async org/user for session 4398228720.
Unexpected error in create_application: (sqlite3.OperationalError) no such table: organizations
[SQL: SELECT organizations.id, organizations.name, organizations.description, organizations.industry, organizations."isActive", organizations."createdAt", organizations."updatedAt" 
FROM organizations 
WHERE organizations.id = ?]
[parameters: ('00000000000000000000000000000001',)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
FDEBUG [conftest.py async_db_session]: Committed default async org/user for session 4400402976.
Unexpected error in create_application: (sqlite3.OperationalError) no such table: organizations
[SQL: SELECT organizations.id, organizations.name, organizations.description, organizations.industry, organizations."isActive", organizations."createdAt", organizations."updatedAt" 
FROM organizations 
WHERE organizations.id = ?]
[parameters: ('00000000000000000000000000000001',)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
FDEBUG [conftest.py async_db_session]: Committed default async org/user for session 4399723040.
Unexpected error in create_application: (sqlite3.OperationalError) no such table: organizations
[SQL: SELECT organizations.id, organizations.name, organizations.description, organizations.industry, organizations."isActive", organizations."createdAt", organizations."updatedAt" 
FROM organizations 
WHERE organizations.id = ?]
[parameters: ('00000000000000000000000000000001',)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
FDEBUG [conftest.py async_db_session]: Committed default async org/user for session 4399744288.
Unexpected error in create_application: (sqlite3.OperationalError) no such table: organizations
[SQL: SELECT organizations.id, organizations.name, organizations.description, organizations.industry, organizations."isActive", organizations."createdAt", organizations."updatedAt" 
FROM organizations 
WHERE organizations.id = ?]
[parameters: ('00000000000000000000000000000001',)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
FDEBUG [conftest.py async_db_session]: Committed default async org/user for session 4399793536.
FDEBUG [conftest.py async_db_session]: Committed default async org/user for session 4418938384.
FDEBUG [conftest.py async_db_session]: Committed default async org/user for session 4415242592.
Unexpected error in create_application: (sqlite3.OperationalError) no such table: organizations
[SQL: SELECT organizations.id, organizations.name, organizations.description, organizations.industry, organizations."isActive", organizations."createdAt", organizations."updatedAt" 
FROM organizations 
WHERE organizations.id = ?]
[parameters: ('00000000000000000000000000000001',)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
FDEBUG [conftest.py async_db_session]: Committed default async org/user for session 4407983408.
Unexpected error in create_application: (sqlite3.OperationalError) no such table: organizations
[SQL: SELECT organizations.id, organizations.name, organizations.description, organizations.industry, organizations."isActive", organizations."createdAt", organizations."updatedAt" 
FROM organizations 
WHERE organizations.id = ?]
[parameters: ('00000000000000000000000000000001',)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
FDEBUG [conftest.py async_db_session]: Committed default async org/user for session 4415233856.
Unexpected error in create_application: (sqlite3.OperationalError) no such table: organizations
[SQL: SELECT organizations.id, organizations.name, organizations.description, organizations.industry, organizations."isActive", organizations."createdAt", organizations."updatedAt" 
FROM organizations 
WHERE organizations.id = ?]
[parameters: ('00000000000000000000000000000001',)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
FDEBUG [conftest.py async_db_session]: Committed default async org/user for session 4406299328.
Unexpected error in update_application: (sqlite3.OperationalError) no such table: applications
[SQL: SELECT applications.id, applications.name, applications.description, applications.type, applications."hostedOn", applications.workarounds, applications."derivedRTO", applications.status, applications."organizationId", applications."appOwnerId", organizations_1.id AS id_1, organizations_1.name AS name_1, organizations_1.description AS description_1, organizations_1.industry, organizations_1."isActive", organizations_1."createdAt", organizations_1."updatedAt", users_1.id AS id_2, users_1."firstName", users_1."lastName", users_1.email, users_1."passwordHash", users_1."jobTitle", users_1."isActive" AS "isActive_1", users_1."createdAt" AS "createdAt_1", users_1."updatedAt" AS "updatedAt_1", users_1."organizationId" AS "organizationId_1", users_1."departmentId", users_1."locationId" 
FROM applications LEFT OUTER JOIN organizations AS organizations_1 ON organizations_1.id = applications."organizationId" LEFT OUTER JOIN users AS users_1 ON users_1.id = applications."appOwnerId" 
WHERE applications.id = ? AND applications."organizationId" = ? AND applications.status = ?]
[parameters: ('b7c046f9287a43fea15eb5c4ea488bc4', '00000000000000000000000000000001', 'ACTIVE')]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
FDEBUG [conftest.py async_db_session]: Committed default async org/user for session 4563534704.
Unexpected error in create_application: (sqlite3.OperationalError) no such table: organizations
[SQL: SELECT organizations.id, organizations.name, organizations.description, organizations.industry, organizations."isActive", organizations."createdAt", organizations."updatedAt" 
FROM organizations 
WHERE organizations.id = ?]
[parameters: ('00000000000000000000000000000001',)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
FDEBUG [conftest.py async_db_session]: Committed default async org/user for session 4402025040.
Unexpected error in create_application: (sqlite3.OperationalError) no such table: organizations
[SQL: SELECT organizations.id, organizations.name, organizations.description, organizations.industry, organizations."isActive", organizations."createdAt", organizations."updatedAt" 
FROM organizations 
WHERE organizations.id = ?]
[parameters: ('00000000000000000000000000000001',)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
FDEBUG [conftest.py async_db_session]: Committed default async org/user for session 4563407536.
Unexpected error in delete_application: (sqlite3.OperationalError) no such table: applications
[SQL: SELECT applications.id, applications.name, applications.description, applications.type, applications."hostedOn", applications.workarounds, applications."derivedRTO", applications.status, applications."organizationId", applications."appOwnerId", organizations_1.id AS id_1, organizations_1.name AS name_1, organizations_1.description AS description_1, organizations_1.industry, organizations_1."isActive", organizations_1."createdAt", organizations_1."updatedAt", users_1.id AS id_2, users_1."firstName", users_1."lastName", users_1.email, users_1."passwordHash", users_1."jobTitle", users_1."isActive" AS "isActive_1", users_1."createdAt" AS "createdAt_1", users_1."updatedAt" AS "updatedAt_1", users_1."organizationId" AS "organizationId_1", users_1."departmentId", users_1."locationId" 
FROM applications LEFT OUTER JOIN organizations AS organizations_1 ON organizations_1.id = applications."organizationId" LEFT OUTER JOIN users AS users_1 ON users_1.id = applications."appOwnerId" 
WHERE applications.id = ? AND applications."organizationId" = ? AND applications.status = ?]
[parameters: ('340c249cb2db4925b9e57c24a10dbb8a', '00000000000000000000000000000001', 'ACTIVE')]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
FDEBUG [conftest.py async_db_session]: Committed default async org/user for session 4566886144.
EDEBUG [conftest.py async_db_session]: Committed default async org/user for session 4405169024.
EUnexpected error in create_application: (sqlite3.OperationalError) no such table: organizations
[SQL: SELECT organizations.id, organizations.name, organizations.description, organizations.industry, organizations."isActive", organizations."createdAt", organizations."updatedAt" 
FROM organizations 
WHERE organizations.id = ?]
[parameters: ('a08faef6ce1f4fa3b33e7dfd2c1f5b2a',)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
FDEBUG [conftest.py create_test_tables_async]: Dropping async tables...
DEBUG [conftest.py create_test_tables_async]: Async tables dropped.
DEBUG [conftest.py create_test_tables]: All tables dropped.


==================================== ERRORS ====================================
______ ERROR at setup of test_update_application_cross_organization_fail _______
file /Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/backend/app/tests/api/test_applications_api.py, line 602
  @pytest.mark.asyncio
  async def test_update_application_cross_organization_fail(
      authenticated_test_client: AsyncClient,
      async_db_session: AsyncSession,
      async_current_test_user: UserModel
  ):
      # Create an organization different from the current_test_user's organization
      other_org = await create_test_organization_async(async_db_session, name="Other Org For Cross-Update Test")
      other_org_owner = await create_test_user_async(async_db_session, organization_id=other_org.id, first_name_prefix="OtherOrgOwnerUpdate")
      # No need to commit here as helper functions do it

      # Create an application in this 'other_org'
      cross_org_app_to_update = ApplicationModel(
          id=uuid.uuid4(),
          name="Cross-Org App For Update Test",
          organization_id=other_org.id,
          app_owner_id=other_org_owner.id,
          type=ApplicationType.OWNED.value,
          status="ACTIVE",
          created_by_id=async_current_test_user.id # Use current user for created_by_id
      )
      async_db_session.add(cross_org_app_to_update)
      await async_db_session.commit()
      await async_db_session.refresh(cross_org_app_to_update)

      update_payload = ApplicationUpdate(name="Attempted Cross-Org Update")

      # current_test_user (from a different org) attempts to update this app
      response = await authenticated_test_client.put(
          f"/api/v1/applications/{cross_org_app_to_update.id}",
          json=update_payload.model_dump(mode='json', exclude_unset=True)
      )

      assert response.status_code == 404, response.text
      assert response.json()["detail"] == "Application not found"
E       fixture 'async_current_test_user' not found
>       available fixtures: _class_event_loop, _function_event_loop, _module_event_loop, _package_event_loop, _session_event_loop, anyio_backend, anyio_backend_name, anyio_backend_options, async_db_session, async_engine_fixture, authenticated_test_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, create_test_tables, create_test_tables_async, current_test_user, db_session, doctest_namespace, event_loop, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, monkeypatch, override_get_async_db, override_get_db, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, test_client, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/backend/app/tests/api/test_applications_api.py:602
______ ERROR at setup of test_delete_application_cross_organization_fail _______
file /Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/backend/app/tests/api/test_applications_api.py, line 638
  @pytest.mark.asyncio
  async def test_delete_application_cross_organization_fail(
      authenticated_test_client: AsyncClient,
      async_db_session: AsyncSession,
      async_current_test_user: UserModel
  ):
      # Create an organization different from the current_test_user's organization
      other_org = await create_test_organization_async(async_db_session, name="Other Org For Cross-Delete Test")
      other_org_owner = await create_test_user_async(async_db_session, organization_id=other_org.id, first_name_prefix="OtherOrgOwnerDelete")

      # Create an application in this 'other_org'
      cross_org_app_to_delete = ApplicationModel(
          id=uuid.uuid4(),
          name="Cross-Org App To Delete Test",
          organization_id=other_org.id,
          app_owner_id=other_org_owner.id,
          type=ApplicationType.OWNED.value,
          status="ACTIVE",
          created_by_id=async_current_test_user.id # Use current user for created_by_id
      )
      async_db_session.add(cross_org_app_to_delete)
      await async_db_session.commit()
      await async_db_session.refresh(cross_org_app_to_delete)

      # current_test_user (from a different org) attempts to delete this app
      response = await authenticated_test_client.delete(f"/api/v1/applications/{cross_org_app_to_delete.id}")

      assert response.status_code == 404, response.text
      assert response.json()["detail"] == "Application not found"
E       fixture 'async_current_test_user' not found
>       available fixtures: _class_event_loop, _function_event_loop, _module_event_loop, _package_event_loop, _session_event_loop, anyio_backend, anyio_backend_name, anyio_backend_options, async_db_session, async_engine_fixture, authenticated_test_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, create_test_tables, create_test_tables_async, current_test_user, db_session, doctest_namespace, event_loop, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, monkeypatch, override_get_async_db, override_get_db, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, test_client, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/backend/app/tests/api/test_applications_api.py:638
=================================== FAILURES ===================================
___________________________ test_create_application ____________________________

authenticated_test_client = <httpx.AsyncClient object at 0x1061c8fa0>
async_db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x1062184f0>
current_test_user = <User(id=00000000-0000-0000-0000-000000000002, email='default.async.user@example.com')>

    @pytest.mark.asyncio
    async def test_create_application(authenticated_test_client: AsyncClient, async_db_session: AsyncSession, current_test_user: UserModel):
        # current_test_user is assumed to be from the authenticated_test_client's token
        # The application's organization will be derived from this user.
        org_id_from_auth_user = current_test_user.organization_id
    
        # Create an app_owner in the same organization as the authenticated user
        app_owner = await create_test_user_async(async_db_session, organization_id=org_id_from_auth_user, first_name_prefix="AppOwnerFull")
    
        application_data = ApplicationCreate(
            name="My New Critical App",
            description="A very important application for testing purposes.",
            app_owner_id=app_owner.id, # Use the ID of the created user
            type=ApplicationType.OWNED.value,
            organization_id=str(org_id_from_auth_user),
            is_active=True,
            hosted_on="Cloud Provider X",
            workarounds="Use manual process as a workaround."
        )
    
        response = await authenticated_test_client.post("/api/v1/applications/", json=application_data.model_dump(mode='json'))
    
>       assert response.status_code == 201, response.text
E       AssertionError: {"detail":"An unexpected error occurred while creating the application."}
E       assert 500 == 201
E        +  where 500 = <Response [500 Internal Server Error]>.status_code

backend/app/tests/api/test_applications_api.py:100: AssertionError
_____________________ test_create_application_minimal_data _____________________

authenticated_test_client = <httpx.AsyncClient object at 0x10639cb80>
current_test_user = <User(id=00000000-0000-0000-0000-000000000002, email='default.async.user@example.com')>

    @pytest.mark.asyncio
    async def test_create_application_minimal_data(authenticated_test_client: AsyncClient, current_test_user: UserModel):
        # The application's organization will be derived from current_test_user.
        org_id_from_auth_user = current_test_user.organization_id
    
        application_data = ApplicationCreate(
            name="Minimal App For Test",
            type=ApplicationType.SAAS.value, # Software as a Service
            organization_id=str(org_id_from_auth_user),
            is_active=True
            # No app_owner_id, description, hosted_on, workarounds
        )
        response = await authenticated_test_client.post("/api/v1/applications/", json=application_data.model_dump(mode='json'))
>       assert response.status_code == 201, response.text
E       AssertionError: {"detail":"An unexpected error occurred while creating the application."}
E       assert 500 == 201
E        +  where 500 = <Response [500 Internal Server Error]>.status_code

backend/app/tests/api/test_applications_api.py:129: AssertionError
_________________ test_create_application_invalid_app_owner_id _________________

authenticated_test_client = <httpx.AsyncClient object at 0x10639c460>
async_db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x10648d220>
current_test_user = <User(id=00000000-0000-0000-0000-000000000002, email='default.async.user@example.com')>

    @pytest.mark.asyncio
    async def test_create_application_invalid_app_owner_id(authenticated_test_client: AsyncClient, async_db_session: AsyncSession, current_test_user: UserModel):
        # current_test_user.organization_id will be the app's organization
        # Create a different organization for the invalid app owner
        org_other = await create_test_organization_async(async_db_session, name="Other Org For Invalid Owner")
        app_owner_other_org = await create_test_user_async(async_db_session, organization_id=org_other.id, first_name_prefix="OtherOrgOwner")
    
        application_data = ApplicationCreate(
            name="App With Cross-Org Owner",
            type=ApplicationType.OWNED.value, # Commercial Off-The-Shelf
            organization_id=str(current_test_user.organization_id),
            is_active=True,
            app_owner_id=app_owner_other_org.id # Owner from a different org
        )
    
        response = await authenticated_test_client.post("/api/v1/applications/", json=application_data.model_dump(mode='json'))
    
>       assert response.status_code == 422, response.text
E       AssertionError: {"detail":"An unexpected error occurred while creating the application."}
E       assert 500 == 422
E        +  where 500 = <Response [500 Internal Server Error]>.status_code

backend/app/tests/api/test_applications_api.py:158: AssertionError
____________________ test_create_application_duplicate_name ____________________

authenticated_test_client = <httpx.AsyncClient object at 0x10639c760>
async_db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x1063e7220>
current_test_user = <User(id=00000000-0000-0000-0000-000000000002, email='default.async.user@example.com')>

    @pytest.mark.asyncio
    async def test_create_application_duplicate_name(authenticated_test_client: AsyncClient, async_db_session: AsyncSession, current_test_user: UserModel):
        # The application's organization will be derived from current_test_user.
        app_owner_same_org = await create_test_user_async(async_db_session, organization_id=current_test_user.organization_id, first_name_prefix="DuplicateNameOwner")
    
        app_name = f"Unique App Name {uuid.uuid4()}"
    
        application_data_1 = ApplicationCreate(
            name=app_name,
            type=ApplicationType.OWNED.value,
            organization_id=str(current_test_user.organization_id),
            is_active=True,
            app_owner_id=app_owner_same_org.id
        )
        response1 = await authenticated_test_client.post("/api/v1/applications/", json=application_data_1.model_dump(mode='json'))
>       assert response1.status_code == 201, response1.text
E       AssertionError: {"detail":"An unexpected error occurred while creating the application."}
E       assert 500 == 201
E        +  where 500 = <Response [500 Internal Server Error]>.status_code

backend/app/tests/api/test_applications_api.py:176: AssertionError
____________________________ test_read_application _____________________________

authenticated_test_client = <httpx.AsyncClient object at 0x1063efd90>
db_session = <sqlalchemy.orm.session.Session object at 0x1063fd1f0>
current_test_user = <User(id=00000000-0000-0000-0000-000000000002, email='default.async.user@example.com')>

    @pytest.mark.asyncio
    async def test_read_application(authenticated_test_client: AsyncClient, db_session: Session, current_test_user: UserModel):
        org_id_current_user = current_test_user.organization_id
        app_owner = create_test_user(db_session, organization_id=org_id_current_user, first_name_prefix="ReadableAppOwner")
    
        application_create_data = ApplicationCreate(
            name="My Readable App",
            description="Description for readable app.",
            app_owner_id=app_owner.id,
            type=ApplicationType.OWNED.value,
            organization_id=str(org_id_current_user),
            is_active=True,
            hosted_on="On-Premise"
        )
    
        create_response = await authenticated_test_client.post("/api/v1/applications/", json=application_create_data.model_dump(mode='json'))
>       assert create_response.status_code == 201, create_response.text
E       AssertionError: {"detail":"An unexpected error occurred while creating the application."}
E       assert 500 == 201
E        +  where 500 = <Response [500 Internal Server Error]>.status_code

backend/app/tests/api/test_applications_api.py:207: AssertionError
_______________________ test_read_application_not_found ________________________

self = <sqlalchemy.engine.base.Connection object at 0x106413970>
dialect = <sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite object at 0x105855d30>
context = <sqlalchemy.dialects.sqlite.aiosqlite.SQLiteExecutionContext_aiosqlite object at 0x106413af0>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x1064139a0>
parameters = [('ccf9482b0745442e8f602a37bb7158a2', '00000000000000000000000000000001', 'ACTIVE')]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.9/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.9/site-packages/sqlalchemy/engine/default.py:943: in do_execute
    cursor.execute(statement, parameters)
venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:149: in execute
    self._adapt_connection._handle_exception(error)
venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:300: in _handle_exception
    raise error
venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:131: in execute
    self.await_(_cursor.execute(operation, parameters))
venv/lib/python3.9/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
venv/lib/python3.9/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
venv/lib/python3.9/site-packages/aiosqlite/cursor.py:40: in execute
    await self._execute(self._cursor.execute, sql, parameters)
venv/lib/python3.9/site-packages/aiosqlite/cursor.py:32: in _execute
    return await self._conn._execute(fn, *args, **kwargs)
venv/lib/python3.9/site-packages/aiosqlite/core.py:122: in _execute
    return await future
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Connection(Thread-2, started daemon 6177845248)>

    def run(self) -> None:
        """
        Execute function calls on a separate thread.
    
        :meta private:
        """
        while True:
            # Continues running until all queue items are processed,
            # even after connection is closed (so we can finalize all
            # futures)
    
            tx_item = self._tx.get()
            if tx_item is _STOP_RUNNING_SENTINEL:
                break
    
            future, function = tx_item
    
            try:
                LOG.debug("executing %s", function)
>               result = function()
E               sqlite3.OperationalError: no such table: applications

venv/lib/python3.9/site-packages/aiosqlite/core.py:105: OperationalError

The above exception was the direct cause of the following exception:

authenticated_test_client = <httpx.AsyncClient object at 0x106418a00>
db_session = <sqlalchemy.orm.session.Session object at 0x1063e7af0>
current_test_user = <User(id=00000000-0000-0000-0000-000000000002, email='default.async.user@example.com')>

    @pytest.mark.asyncio
    async def test_read_application_not_found(authenticated_test_client: AsyncClient, db_session: Session, current_test_user: UserModel): # Added current_test_user for consistency
        non_existent_app_id = uuid.uuid4()
>       response = await authenticated_test_client.get(f"/api/v1/applications/{non_existent_app_id}")

backend/app/tests/api/test_applications_api.py:255: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.9/site-packages/httpx/_client.py:1768: in get
    return await self.request(
venv/lib/python3.9/site-packages/httpx/_client.py:1540: in request
    return await self.send(request, auth=auth, follow_redirects=follow_redirects)
venv/lib/python3.9/site-packages/httpx/_client.py:1629: in send
    response = await self._send_handling_auth(
venv/lib/python3.9/site-packages/httpx/_client.py:1657: in _send_handling_auth
    response = await self._send_handling_redirects(
venv/lib/python3.9/site-packages/httpx/_client.py:1694: in _send_handling_redirects
    response = await self._send_single_request(request)
venv/lib/python3.9/site-packages/httpx/_client.py:1730: in _send_single_request
    response = await transport.handle_async_request(request)
venv/lib/python3.9/site-packages/httpx/_transports/asgi.py:170: in handle_async_request
    await self.app(scope, receive, send)
venv/lib/python3.9/site-packages/fastapi/applications.py:1054: in __call__
    await super().__call__(scope, receive, send)
venv/lib/python3.9/site-packages/starlette/applications.py:112: in __call__
    await self.middleware_stack(scope, receive, send)
venv/lib/python3.9/site-packages/starlette/middleware/errors.py:187: in __call__
    raise exc
venv/lib/python3.9/site-packages/starlette/middleware/errors.py:165: in __call__
    await self.app(scope, receive, _send)
venv/lib/python3.9/site-packages/starlette/middleware/cors.py:85: in __call__
    await self.app(scope, receive, send)
venv/lib/python3.9/site-packages/starlette/middleware/exceptions.py:62: in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
venv/lib/python3.9/site-packages/starlette/_exception_handler.py:53: in wrapped_app
    raise exc
venv/lib/python3.9/site-packages/starlette/_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
venv/lib/python3.9/site-packages/starlette/routing.py:714: in __call__
    await self.middleware_stack(scope, receive, send)
venv/lib/python3.9/site-packages/starlette/routing.py:734: in app
    await route.handle(scope, receive, send)
venv/lib/python3.9/site-packages/starlette/routing.py:288: in handle
    await self.app(scope, receive, send)
venv/lib/python3.9/site-packages/starlette/routing.py:76: in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
venv/lib/python3.9/site-packages/starlette/_exception_handler.py:53: in wrapped_app
    raise exc
venv/lib/python3.9/site-packages/starlette/_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
venv/lib/python3.9/site-packages/starlette/routing.py:73: in app
    response = await f(request)
venv/lib/python3.9/site-packages/fastapi/routing.py:301: in app
    raw_response = await run_endpoint_function(
venv/lib/python3.9/site-packages/fastapi/routing.py:212: in run_endpoint_function
    return await dependant.call(**values)
backend/app/apis/endpoints/applications.py:53: in read_application
    db_application = await application_service.get_application_by_id(
backend/app/services/application_service.py:34: in get_application_by_id
    result = await db.execute(stmt)
venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/session.py:463: in execute
    result = await greenlet_spawn(
venv/lib/python3.9/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
venv/lib/python3.9/site-packages/sqlalchemy/orm/session.py:2365: in execute
    return self._execute_internal(
venv/lib/python3.9/site-packages/sqlalchemy/orm/session.py:2251: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
venv/lib/python3.9/site-packages/sqlalchemy/orm/context.py:306: in orm_execute_statement
    result = conn.execute(
venv/lib/python3.9/site-packages/sqlalchemy/engine/base.py:1415: in execute
    return meth(
venv/lib/python3.9/site-packages/sqlalchemy/sql/elements.py:523: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.9/site-packages/sqlalchemy/engine/base.py:1637: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.9/site-packages/sqlalchemy/engine/base.py:1842: in _execute_context
    return self._exec_single_context(
venv/lib/python3.9/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.9/site-packages/sqlalchemy/engine/base.py:2351: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.9/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
venv/lib/python3.9/site-packages/sqlalchemy/engine/default.py:943: in do_execute
    cursor.execute(statement, parameters)
venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:149: in execute
    self._adapt_connection._handle_exception(error)
venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:300: in _handle_exception
    raise error
venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:131: in execute
    self.await_(_cursor.execute(operation, parameters))
venv/lib/python3.9/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
venv/lib/python3.9/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
venv/lib/python3.9/site-packages/aiosqlite/cursor.py:40: in execute
    await self._execute(self._cursor.execute, sql, parameters)
venv/lib/python3.9/site-packages/aiosqlite/cursor.py:32: in _execute
    return await self._conn._execute(fn, *args, **kwargs)
venv/lib/python3.9/site-packages/aiosqlite/core.py:122: in _execute
    return await future
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Connection(Thread-2, started daemon 6177845248)>

    def run(self) -> None:
        """
        Execute function calls on a separate thread.
    
        :meta private:
        """
        while True:
            # Continues running until all queue items are processed,
            # even after connection is closed (so we can finalize all
            # futures)
    
            tx_item = self._tx.get()
            if tx_item is _STOP_RUNNING_SENTINEL:
                break
    
            future, function = tx_item
    
            try:
                LOG.debug("executing %s", function)
>               result = function()
E               sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: applications
E               [SQL: SELECT applications.id, applications.name, applications.description, applications.type, applications."hostedOn", applications.workarounds, applications."derivedRTO", applications.status, applications."organizationId", applications."appOwnerId", organizations_1.id AS id_1, organizations_1.name AS name_1, organizations_1.description AS description_1, organizations_1.industry, organizations_1."isActive", organizations_1."createdAt", organizations_1."updatedAt", users_1.id AS id_2, users_1."firstName", users_1."lastName", users_1.email, users_1."passwordHash", users_1."jobTitle", users_1."isActive" AS "isActive_1", users_1."createdAt" AS "createdAt_1", users_1."updatedAt" AS "updatedAt_1", users_1."organizationId" AS "organizationId_1", users_1."departmentId", users_1."locationId" 
E               FROM applications LEFT OUTER JOIN organizations AS organizations_1 ON organizations_1.id = applications."organizationId" LEFT OUTER JOIN users AS users_1 ON users_1.id = applications."appOwnerId" 
E               WHERE applications.id = ? AND applications."organizationId" = ? AND applications.status = ?]
E               [parameters: ('ccf9482b0745442e8f602a37bb7158a2', '00000000000000000000000000000001', 'ACTIVE')]
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.9/site-packages/aiosqlite/core.py:105: OperationalError
_________________________ test_read_applications_empty _________________________

self = <sqlalchemy.engine.base.Connection object at 0x107055070>
dialect = <sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite object at 0x105855d30>
context = <sqlalchemy.dialects.sqlite.aiosqlite.SQLiteExecutionContext_aiosqlite object at 0x107055d30>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x1059dbc40>
parameters = [('00000000000000000000000000000001', 'ACTIVE', 100, 0)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv/lib/python3.9/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.9/site-packages/sqlalchemy/engine/default.py:943: in do_execute
    cursor.execute(statement, parameters)
venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:149: in execute
    self._adapt_connection._handle_exception(error)
venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:300: in _handle_exception
    raise error
venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:131: in execute
    self.await_(_cursor.execute(operation, parameters))
venv/lib/python3.9/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
venv/lib/python3.9/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
venv/lib/python3.9/site-packages/aiosqlite/cursor.py:40: in execute
    await self._execute(self._cursor.execute, sql, parameters)
venv/lib/python3.9/site-packages/aiosqlite/cursor.py:32: in _execute
    return await self._conn._execute(fn, *args, **kwargs)
venv/lib/python3.9/site-packages/aiosqlite/core.py:122: in _execute
    return await future
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Connection(Thread-2, started daemon 6177845248)>

    def run(self) -> None:
        """
        Execute function calls on a separate thread.
    
        :meta private:
        """
        while True:
            # Continues running until all queue items are processed,
            # even after connection is closed (so we can finalize all
            # futures)
    
            tx_item = self._tx.get()
            if tx_item is _STOP_RUNNING_SENTINEL:
                break
    
            future, function = tx_item
    
            try:
                LOG.debug("executing %s", function)
>               result = function()
E               sqlite3.OperationalError: no such table: applications

venv/lib/python3.9/site-packages/aiosqlite/core.py:105: OperationalError

The above exception was the direct cause of the following exception:

authenticated_test_client = <httpx.AsyncClient object at 0x110022550>
current_test_user = <User(id=00000000-0000-0000-0000-000000000002, email='default.async.user@example.com')>

    @pytest.mark.asyncio
    async def test_read_applications_empty(authenticated_test_client: AsyncClient, current_test_user: UserModel): # Added current_test_user
        # This test assumes that for the current_test_user's organization, no applications exist yet.
        # If other tests create apps for this org without cleaning up, this test might be flaky.
        # Consider adding cleanup or ensuring a fresh org for this test if needed.
>       response = await authenticated_test_client.get("/api/v1/applications/")

backend/app/tests/api/test_applications_api.py:264: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.9/site-packages/httpx/_client.py:1768: in get
    return await self.request(
venv/lib/python3.9/site-packages/httpx/_client.py:1540: in request
    return await self.send(request, auth=auth, follow_redirects=follow_redirects)
venv/lib/python3.9/site-packages/httpx/_client.py:1629: in send
    response = await self._send_handling_auth(
venv/lib/python3.9/site-packages/httpx/_client.py:1657: in _send_handling_auth
    response = await self._send_handling_redirects(
venv/lib/python3.9/site-packages/httpx/_client.py:1694: in _send_handling_redirects
    response = await self._send_single_request(request)
venv/lib/python3.9/site-packages/httpx/_client.py:1730: in _send_single_request
    response = await transport.handle_async_request(request)
venv/lib/python3.9/site-packages/httpx/_transports/asgi.py:170: in handle_async_request
    await self.app(scope, receive, send)
venv/lib/python3.9/site-packages/fastapi/applications.py:1054: in __call__
    await super().__call__(scope, receive, send)
venv/lib/python3.9/site-packages/starlette/applications.py:112: in __call__
    await self.middleware_stack(scope, receive, send)
venv/lib/python3.9/site-packages/starlette/middleware/errors.py:187: in __call__
    raise exc
venv/lib/python3.9/site-packages/starlette/middleware/errors.py:165: in __call__
    await self.app(scope, receive, _send)
venv/lib/python3.9/site-packages/starlette/middleware/cors.py:85: in __call__
    await self.app(scope, receive, send)
venv/lib/python3.9/site-packages/starlette/middleware/exceptions.py:62: in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
venv/lib/python3.9/site-packages/starlette/_exception_handler.py:53: in wrapped_app
    raise exc
venv/lib/python3.9/site-packages/starlette/_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
venv/lib/python3.9/site-packages/starlette/routing.py:714: in __call__
    await self.middleware_stack(scope, receive, send)
venv/lib/python3.9/site-packages/starlette/routing.py:734: in app
    await route.handle(scope, receive, send)
venv/lib/python3.9/site-packages/starlette/routing.py:288: in handle
    await self.app(scope, receive, send)
venv/lib/python3.9/site-packages/starlette/routing.py:76: in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
venv/lib/python3.9/site-packages/starlette/_exception_handler.py:53: in wrapped_app
    raise exc
venv/lib/python3.9/site-packages/starlette/_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
venv/lib/python3.9/site-packages/starlette/routing.py:73: in app
    response = await f(request)
venv/lib/python3.9/site-packages/fastapi/routing.py:301: in app
    raw_response = await run_endpoint_function(
venv/lib/python3.9/site-packages/fastapi/routing.py:212: in run_endpoint_function
    return await dependant.call(**values)
backend/app/apis/endpoints/applications.py:73: in read_applications
    applications = await application_service.get_applications(
backend/app/services/application_service.py:52: in get_applications
    result = await db.execute(stmt)
venv/lib/python3.9/site-packages/sqlalchemy/ext/asyncio/session.py:463: in execute
    result = await greenlet_spawn(
venv/lib/python3.9/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
venv/lib/python3.9/site-packages/sqlalchemy/orm/session.py:2365: in execute
    return self._execute_internal(
venv/lib/python3.9/site-packages/sqlalchemy/orm/session.py:2251: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
venv/lib/python3.9/site-packages/sqlalchemy/orm/context.py:306: in orm_execute_statement
    result = conn.execute(
venv/lib/python3.9/site-packages/sqlalchemy/engine/base.py:1415: in execute
    return meth(
venv/lib/python3.9/site-packages/sqlalchemy/sql/elements.py:523: in _execute_on_connection
    return connection._execute_clauseelement(
venv/lib/python3.9/site-packages/sqlalchemy/engine/base.py:1637: in _execute_clauseelement
    ret = self._execute_context(
venv/lib/python3.9/site-packages/sqlalchemy/engine/base.py:1842: in _execute_context
    return self._exec_single_context(
venv/lib/python3.9/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
venv/lib/python3.9/site-packages/sqlalchemy/engine/base.py:2351: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv/lib/python3.9/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
venv/lib/python3.9/site-packages/sqlalchemy/engine/default.py:943: in do_execute
    cursor.execute(statement, parameters)
venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:149: in execute
    self._adapt_connection._handle_exception(error)
venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:300: in _handle_exception
    raise error
venv/lib/python3.9/site-packages/sqlalchemy/dialects/sqlite/aiosqlite.py:131: in execute
    self.await_(_cursor.execute(operation, parameters))
venv/lib/python3.9/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
venv/lib/python3.9/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
venv/lib/python3.9/site-packages/aiosqlite/cursor.py:40: in execute
    await self._execute(self._cursor.execute, sql, parameters)
venv/lib/python3.9/site-packages/aiosqlite/cursor.py:32: in _execute
    return await self._conn._execute(fn, *args, **kwargs)
venv/lib/python3.9/site-packages/aiosqlite/core.py:122: in _execute
    return await future
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Connection(Thread-2, started daemon 6177845248)>

    def run(self) -> None:
        """
        Execute function calls on a separate thread.
    
        :meta private:
        """
        while True:
            # Continues running until all queue items are processed,
            # even after connection is closed (so we can finalize all
            # futures)
    
            tx_item = self._tx.get()
            if tx_item is _STOP_RUNNING_SENTINEL:
                break
    
            future, function = tx_item
    
            try:
                LOG.debug("executing %s", function)
>               result = function()
E               sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: applications
E               [SQL: SELECT applications.id, applications.name, applications.description, applications.type, applications."hostedOn", applications.workarounds, applications."derivedRTO", applications.status, applications."organizationId", applications."appOwnerId", organizations_1.id AS id_1, organizations_1.name AS name_1, organizations_1.description AS description_1, organizations_1.industry, organizations_1."isActive", organizations_1."createdAt", organizations_1."updatedAt", users_1.id AS id_2, users_1."firstName", users_1."lastName", users_1.email, users_1."passwordHash", users_1."jobTitle", users_1."isActive" AS "isActive_1", users_1."createdAt" AS "createdAt_1", users_1."updatedAt" AS "updatedAt_1", users_1."organizationId" AS "organizationId_1", users_1."departmentId", users_1."locationId" 
E               FROM applications LEFT OUTER JOIN organizations AS organizations_1 ON organizations_1.id = applications."organizationId" LEFT OUTER JOIN users AS users_1 ON users_1.id = applications."appOwnerId" 
E               WHERE applications."organizationId" = ? AND applications.status = ? ORDER BY applications.name
E                LIMIT ? OFFSET ?]
E               [parameters: ('00000000000000000000000000000001', 'ACTIVE', 100, 0)]
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

venv/lib/python3.9/site-packages/aiosqlite/core.py:105: OperationalError
_________________________ test_read_applications_list __________________________

authenticated_test_client = <httpx.AsyncClient object at 0x1072b1700>
db_session = <sqlalchemy.orm.session.Session object at 0x1103a8b20>
current_test_user = <User(id=00000000-0000-0000-0000-000000000002, email='default.async.user@example.com')>

    @pytest.mark.asyncio
    async def test_read_applications_list(authenticated_test_client: AsyncClient, db_session: Session, current_test_user: UserModel):
        org_id_current_user = current_test_user.organization_id
        app_owner1 = create_test_user(db_session, organization_id=org_id_current_user, first_name_prefix="ListAppOwner1")
        app_owner2 = create_test_user(db_session, organization_id=org_id_current_user, first_name_prefix="ListAppOwner2")
    
        app1_create_data = ApplicationCreate(
            name="Listed App Alpha",
            type=ApplicationType.OWNED.value,
            organization_id=str(org_id_current_user),
            is_active=True,
            app_owner_id=app_owner1.id
        )
        app2_create_data = ApplicationCreate(
            name="Listed App Beta",
            type=ApplicationType.OWNED.value,
            organization_id=str(org_id_current_user),
            is_active=True,
            app_owner_id=app_owner2.id,
            description="Beta version"
        )
    
        # Create two applications in the current user's organization
        response_create1 = await authenticated_test_client.post("/api/v1/applications/", json=app1_create_data.model_dump(mode='json'))
>       assert response_create1.status_code == 201, response_create1.text
E       AssertionError: {"detail":"An unexpected error occurred while creating the application."}
E       assert 500 == 201
E        +  where 500 = <Response [500 Internal Server Error]>.status_code

backend/app/tests/api/test_applications_api.py:296: AssertionError
_______________ test_read_applications_pagination_and_filtering ________________

authenticated_test_client = <httpx.AsyncClient object at 0x106c28ca0>
db_session = <sqlalchemy.orm.session.Session object at 0x1072b1040>
current_test_user = <User(id=00000000-0000-0000-0000-000000000002, email='default.async.user@example.com')>

    @pytest.mark.asyncio
    async def test_read_applications_pagination_and_filtering(authenticated_test_client: AsyncClient, db_session: Session, current_test_user: UserModel):
        org_id = current_test_user.organization_id
        # Helper to create apps for this test via API
        async def _create_app(name: str, app_type: ApplicationType, description: str = "Test app"):
            app_owner = create_test_user(db_session, organization_id=org_id, first_name_prefix=f"Owner{name.replace(' ', '')}")
            payload = ApplicationCreate(name=name, type=app_type, organization_id=str(org_id), app_owner_id=app_owner.id, description=description, is_active=True)
            response = await authenticated_test_client.post("/api/v1/applications/", json=payload.model_dump(mode='json'))
            assert response.status_code == 201, f"Failed to create {name}: {response.text}"
            return response.json()
    
        # Create a set of applications
        app_configs = [
            {"name": "Alpha App", "type": ApplicationType.OWNED.value, "desc": "Alpha custom app"},
            {"name": "Bravo App", "type": ApplicationType.SAAS.value, "desc": "Bravo SaaS solution"},
            {"name": "Charlie App", "type": ApplicationType.OWNED.value, "desc": "Charlie custom app"},
            {"name": "Delta App", "type": ApplicationType.OWNED.value, "desc": "Delta COTS package"},
            {"name": "Echo App", "type": ApplicationType.SAAS.value, "desc": "Echo SaaS platform"},
            {"name": "Foxtrot App Special", "type": ApplicationType.OWNED.value, "desc": "Foxtrot special project"}
        ]
        created_apps = []
        for config in app_configs:
>           app_data = await _create_app(config["name"], config["type"], config["desc"])

backend/app/tests/api/test_applications_api.py:365: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'Alpha App', app_type = 'Owned', description = 'Alpha custom app'

    async def _create_app(name: str, app_type: ApplicationType, description: str = "Test app"):
        app_owner = create_test_user(db_session, organization_id=org_id, first_name_prefix=f"Owner{name.replace(' ', '')}")
        payload = ApplicationCreate(name=name, type=app_type, organization_id=str(org_id), app_owner_id=app_owner.id, description=description, is_active=True)
        response = await authenticated_test_client.post("/api/v1/applications/", json=payload.model_dump(mode='json'))
>       assert response.status_code == 201, f"Failed to create {name}: {response.text}"
E       AssertionError: Failed to create Alpha App: {"detail":"An unexpected error occurred while creating the application."}
E       assert 500 == 201
E        +  where 500 = <Response [500 Internal Server Error]>.status_code

backend/app/tests/api/test_applications_api.py:351: AssertionError
___________________________ test_update_application ____________________________

authenticated_test_client = <httpx.AsyncClient object at 0x10769e700>
db_session = <sqlalchemy.orm.session.Session object at 0x106c28e20>
current_test_user = <User(id=00000000-0000-0000-0000-000000000002, email='default.async.user@example.com')>

    @pytest.mark.asyncio
    async def test_update_application(authenticated_test_client: AsyncClient, db_session: AsyncSession, current_test_user: UserModel):
        org_id = current_test_user.organization_id
        owner_orig = create_test_user(db_session, organization_id=org_id, first_name_prefix="OwnerOrigUpd")
        owner_new = create_test_user(db_session, organization_id=org_id, first_name_prefix="OwnerNewUpd")
    
        app_create_payload = ApplicationCreate(
            name="Original App Name",
            type=ApplicationType.OWNED.value,
            organization_id=str(org_id),
            is_active=True,
            app_owner_id=owner_orig.id,
            description="Original Description",
            criticality="Medium",
            status="ACTIVE" # Assuming status is a simple string, or use ApplicationStatusEnum.ACTIVE.value
        )
        create_response = await authenticated_test_client.post("/api/v1/applications/", json=app_create_payload.model_dump(mode='json'))
>       assert create_response.status_code == 201, create_response.text
E       AssertionError: {"detail":"An unexpected error occurred while creating the application."}
E       assert 500 == 201
E        +  where 500 = <Response [500 Internal Server Error]>.status_code

backend/app/tests/api/test_applications_api.py:478: AssertionError
______________________ test_update_application_not_found _______________________

authenticated_test_client = <httpx.AsyncClient object at 0x10769e670>
current_test_user = <User(id=00000000-0000-0000-0000-000000000002, email='default.async.user@example.com')>

    @pytest.mark.asyncio
    async def test_update_application_not_found(authenticated_test_client: AsyncClient, current_test_user: UserModel):
        non_existent_app_id = uuid.uuid4()
        update_payload = ApplicationUpdate(name="Attempted Update To NonExistent")
        response = await authenticated_test_client.put(f"/api/v1/applications/{non_existent_app_id}", json=update_payload.model_dump(mode='json', exclude_unset=True))
>       assert response.status_code == 404, response.text
E       AssertionError: {"detail":"An unexpected error occurred while updating the application."}
E       assert 500 == 404
E        +  where 500 = <Response [500 Internal Server Error]>.status_code

backend/app/tests/api/test_applications_api.py:509: AssertionError
____________________ test_update_application_invalid_owner _____________________

authenticated_test_client = <httpx.AsyncClient object at 0x106a2c5b0>
db_session = <sqlalchemy.orm.session.Session object at 0x1068988b0>
current_test_user = <User(id=00000000-0000-0000-0000-000000000002, email='default.async.user@example.com')>

    @pytest.mark.asyncio
    async def test_update_application_invalid_owner(authenticated_test_client: AsyncClient, db_session: AsyncSession, current_test_user: UserModel):
        org_id = current_test_user.organization_id
        initial_owner = create_test_user(db_session, organization_id=org_id, first_name_prefix="InitialAppOwner")
    
        app_create_payload = ApplicationCreate(
            name="App For Invalid Owner Update Test",
            type=ApplicationType.OWNED.value,
            organization_id=str(org_id),
            is_active=True,
            app_owner_id=initial_owner.id,
            status="ACTIVE"
        )
        create_response = await authenticated_test_client.post("/api/v1/applications/", json=app_create_payload.model_dump(mode='json'))
>       assert create_response.status_code == 201, create_response.text
E       AssertionError: {"detail":"An unexpected error occurred while creating the application."}
E       assert 500 == 201
E        +  where 500 = <Response [500 Internal Server Error]>.status_code

backend/app/tests/api/test_applications_api.py:526: AssertionError
___________________________ test_delete_application ____________________________

authenticated_test_client = <httpx.AsyncClient object at 0x1066a2c40>
async_db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x106619250>
current_test_user = <User(id=00000000-0000-0000-0000-000000000002, email='default.async.user@example.com')>

    @pytest.mark.asyncio
    async def test_delete_application(authenticated_test_client: AsyncClient, async_db_session: AsyncSession, current_test_user: UserModel):
        org_id = current_test_user.organization_id
        app_owner = await create_test_user_async(async_db_session, organization_id=org_id, first_name_prefix="AppOwnerForDelete")
    
        app_create_payload = ApplicationCreate(
            name="App To Be Soft Deleted",
            type=ApplicationType.OWNED.value,
            organization_id=str(org_id),
            is_active=True,
            app_owner_id=app_owner.id,
            status="ACTIVE"
        )
        create_response = await authenticated_test_client.post("/api/v1/applications/", json=app_create_payload.model_dump(mode='json'))
>       assert create_response.status_code == 201, create_response.text
E       AssertionError: {"detail":"An unexpected error occurred while creating the application."}
E       assert 500 == 201
E        +  where 500 = <Response [500 Internal Server Error]>.status_code

backend/app/tests/api/test_applications_api.py:567: AssertionError
______________________ test_delete_application_not_found _______________________

authenticated_test_client = <httpx.AsyncClient object at 0x1066a24f0>
current_test_user = <User(id=00000000-0000-0000-0000-000000000002, email='default.async.user@example.com')>

    @pytest.mark.asyncio
    async def test_delete_application_not_found(authenticated_test_client: AsyncClient, current_test_user: UserModel):
        non_existent_app_id = uuid.uuid4()
        response = await authenticated_test_client.delete(f"/api/v1/applications/{non_existent_app_id}")
>       assert response.status_code == 404, response.text
E       AssertionError: {"detail":"An unexpected error occurred during deletion."}
E       assert 500 == 404
E        +  where 500 = <Response [500 Internal Server Error]>.status_code

backend/app/tests/api/test_applications_api.py:598: AssertionError
___________________ test_delete_already_deleted_application ____________________

authenticated_test_client = <httpx.AsyncClient object at 0x1069b9520>
db_session = <sqlalchemy.orm.session.Session object at 0x1066a2250>

    @pytest.mark.asyncio
    async def test_delete_already_deleted_application(authenticated_test_client: AsyncClient, db_session: Session):
        org = create_test_organization(db_session, name="AppDeleteTwice Org2")
        org_id = org.id
        if org in db_session: db_session.expunge(org)
    
        app_create_data = ApplicationCreate(name="App To Be Deleted Twice Again", organization_id=str(org_id), type=ApplicationType.SAAS.value, is_active=True)
        create_response = await authenticated_test_client.post("/api/v1/applications/", content=app_create_data.model_dump_json(), headers={"Content-Type": "application/json"})
>       assert create_response.status_code == 201, create_response.text
E       AssertionError: {"detail":"An unexpected error occurred while creating the application."}
E       assert 500 == 201
E        +  where 500 = <Response [500 Internal Server Error]>.status_code

backend/app/tests/api/test_applications_api.py:677: AssertionError
=============================== warnings summary ===============================
backend/app/tests/api/test_applications_api.py::test_create_application
  /Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/backend/app/tests/conftest.py:81: RuntimeWarning: coroutine 'create_test_tables_async.<locals>.do_inspect' was never awaited
    await conn.run_sync(do_inspect)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

backend/app/tests/api/test_applications_api.py::test_create_application
  /Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:723: PytestDeprecationWarning: asyncio test 'test_create_application' requested async @pytest.fixture 'override_get_async_db' in strict mode. You might want to use @pytest_asyncio.fixture or switch to auto mode. This will become an error in future versions of flake8-asyncio.
    warnings.warn(

backend/app/tests/api/test_applications_api.py::test_create_application_minimal_data
  /Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:723: PytestDeprecationWarning: asyncio test 'test_create_application_minimal_data' requested async @pytest.fixture 'override_get_async_db' in strict mode. You might want to use @pytest_asyncio.fixture or switch to auto mode. This will become an error in future versions of flake8-asyncio.
    warnings.warn(

backend/app/tests/api/test_applications_api.py::test_create_application_invalid_app_owner_id
  /Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:723: PytestDeprecationWarning: asyncio test 'test_create_application_invalid_app_owner_id' requested async @pytest.fixture 'override_get_async_db' in strict mode. You might want to use @pytest_asyncio.fixture or switch to auto mode. This will become an error in future versions of flake8-asyncio.
    warnings.warn(

backend/app/tests/api/test_applications_api.py::test_create_application_duplicate_name
  /Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:723: PytestDeprecationWarning: asyncio test 'test_create_application_duplicate_name' requested async @pytest.fixture 'override_get_async_db' in strict mode. You might want to use @pytest_asyncio.fixture or switch to auto mode. This will become an error in future versions of flake8-asyncio.
    warnings.warn(

backend/app/tests/api/test_applications_api.py::test_read_application
  /Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:723: PytestDeprecationWarning: asyncio test 'test_read_application' requested async @pytest.fixture 'override_get_async_db' in strict mode. You might want to use @pytest_asyncio.fixture or switch to auto mode. This will become an error in future versions of flake8-asyncio.
    warnings.warn(

backend/app/tests/api/test_applications_api.py::test_read_application_not_found
  /Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:723: PytestDeprecationWarning: asyncio test 'test_read_application_not_found' requested async @pytest.fixture 'override_get_async_db' in strict mode. You might want to use @pytest_asyncio.fixture or switch to auto mode. This will become an error in future versions of flake8-asyncio.
    warnings.warn(

backend/app/tests/api/test_applications_api.py::test_read_applications_empty
  /Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:723: PytestDeprecationWarning: asyncio test 'test_read_applications_empty' requested async @pytest.fixture 'override_get_async_db' in strict mode. You might want to use @pytest_asyncio.fixture or switch to auto mode. This will become an error in future versions of flake8-asyncio.
    warnings.warn(

backend/app/tests/api/test_applications_api.py::test_read_applications_list
  /Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:723: PytestDeprecationWarning: asyncio test 'test_read_applications_list' requested async @pytest.fixture 'override_get_async_db' in strict mode. You might want to use @pytest_asyncio.fixture or switch to auto mode. This will become an error in future versions of flake8-asyncio.
    warnings.warn(

backend/app/tests/api/test_applications_api.py::test_read_applications_pagination_and_filtering
  /Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:723: PytestDeprecationWarning: asyncio test 'test_read_applications_pagination_and_filtering' requested async @pytest.fixture 'override_get_async_db' in strict mode. You might want to use @pytest_asyncio.fixture or switch to auto mode. This will become an error in future versions of flake8-asyncio.
    warnings.warn(

backend/app/tests/api/test_applications_api.py::test_update_application
  /Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:723: PytestDeprecationWarning: asyncio test 'test_update_application' requested async @pytest.fixture 'override_get_async_db' in strict mode. You might want to use @pytest_asyncio.fixture or switch to auto mode. This will become an error in future versions of flake8-asyncio.
    warnings.warn(

backend/app/tests/api/test_applications_api.py::test_update_application_not_found
  /Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:723: PytestDeprecationWarning: asyncio test 'test_update_application_not_found' requested async @pytest.fixture 'override_get_async_db' in strict mode. You might want to use @pytest_asyncio.fixture or switch to auto mode. This will become an error in future versions of flake8-asyncio.
    warnings.warn(

backend/app/tests/api/test_applications_api.py::test_update_application_invalid_owner
  /Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:723: PytestDeprecationWarning: asyncio test 'test_update_application_invalid_owner' requested async @pytest.fixture 'override_get_async_db' in strict mode. You might want to use @pytest_asyncio.fixture or switch to auto mode. This will become an error in future versions of flake8-asyncio.
    warnings.warn(

backend/app/tests/api/test_applications_api.py::test_delete_application
  /Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:723: PytestDeprecationWarning: asyncio test 'test_delete_application' requested async @pytest.fixture 'override_get_async_db' in strict mode. You might want to use @pytest_asyncio.fixture or switch to auto mode. This will become an error in future versions of flake8-asyncio.
    warnings.warn(

backend/app/tests/api/test_applications_api.py::test_delete_application_not_found
  /Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:723: PytestDeprecationWarning: asyncio test 'test_delete_application_not_found' requested async @pytest.fixture 'override_get_async_db' in strict mode. You might want to use @pytest_asyncio.fixture or switch to auto mode. This will become an error in future versions of flake8-asyncio.
    warnings.warn(

backend/app/tests/api/test_applications_api.py::test_delete_already_deleted_application
  /Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/venv/lib/python3.9/site-packages/pytest_asyncio/plugin.py:723: PytestDeprecationWarning: asyncio test 'test_delete_already_deleted_application' requested async @pytest.fixture 'override_get_async_db' in strict mode. You might want to use @pytest_asyncio.fixture or switch to auto mode. This will become an error in future versions of flake8-asyncio.
    warnings.warn(

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED backend/app/tests/api/test_applications_api.py::test_create_application
FAILED backend/app/tests/api/test_applications_api.py::test_create_application_minimal_data
FAILED backend/app/tests/api/test_applications_api.py::test_create_application_invalid_app_owner_id
FAILED backend/app/tests/api/test_applications_api.py::test_create_application_duplicate_name
FAILED backend/app/tests/api/test_applications_api.py::test_read_application
FAILED backend/app/tests/api/test_applications_api.py::test_read_application_not_found
FAILED backend/app/tests/api/test_applications_api.py::test_read_applications_empty
FAILED backend/app/tests/api/test_applications_api.py::test_read_applications_list
FAILED backend/app/tests/api/test_applications_api.py::test_read_applications_pagination_and_filtering
FAILED backend/app/tests/api/test_applications_api.py::test_update_application
FAILED backend/app/tests/api/test_applications_api.py::test_update_application_not_found
FAILED backend/app/tests/api/test_applications_api.py::test_update_application_invalid_owner
FAILED backend/app/tests/api/test_applications_api.py::test_delete_application
FAILED backend/app/tests/api/test_applications_api.py::test_delete_application_not_found
FAILED backend/app/tests/api/test_applications_api.py::test_delete_already_deleted_application
ERROR backend/app/tests/api/test_applications_api.py::test_update_application_cross_organization_fail
ERROR backend/app/tests/api/test_applications_api.py::test_delete_application_cross_organization_fail
================== 15 failed, 16 warnings, 2 errors in 1.71s ===================
