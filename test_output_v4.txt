INFO [session.py]: Pytest detected. Using in-memory SQLite for tests.
DEBUG [session.py]: Final DATABASE_URL for sync engine: sqlite:///:memory:
DEBUG [session.py]: Final ASYNC_DATABASE_URL for async engine: sqlite+aiosqlite:///:memory:
============================= test session starts ==============================
platform darwin -- Python 3.9.6, pytest-8.3.5, pluggy-1.6.0
rootdir: /Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf
configfile: pytest.ini
plugins: anyio-4.9.0, asyncio-1.0.0
asyncio: mode=strict, asyncio_default_fixture_loop_scope=session, asyncio_default_test_loop_scope=function
collected 17 items

backend/app/tests/api/test_applications_api.py DEBUG [conftest.py create_test_tables]: All tables created.
DEBUG [conftest.py create_test_tables - SYNC]: Table 'people' not found.
DEBUG [conftest.py create_test_tables - SYNC]: Schema for table 'organizations':
  SYNC Column: id, Type: CHAR(32)
  SYNC Column: name, Type: VARCHAR(255)
  SYNC Column: description, Type: TEXT
  SYNC Column: industry, Type: VARCHAR(100)
  SYNC Column: isActive, Type: BOOLEAN
  SYNC Column: createdAt, Type: DATETIME
  SYNC Column: updatedAt, Type: DATETIME
DEBUG [conftest.py create_test_tables - SYNC]: Schema for table 'roles':
  SYNC Column: id, Type: CHAR(32)
  SYNC Column: name, Type: VARCHAR(50)
  SYNC Column: description, Type: TEXT
  SYNC Column: organization_id, Type: CHAR(32)
  SYNC Column: createdAt, Type: DATETIME
  SYNC Column: updatedAt, Type: DATETIME
DEBUG [conftest.py create_test_tables - SYNC]: Schema for table 'permissions':
  SYNC Column: id, Type: CHAR(32)
  SYNC Column: name, Type: VARCHAR(255)
  SYNC Column: description, Type: TEXT
  SYNC Column: createdAt, Type: DATETIME
  SYNC Column: updatedAt, Type: DATETIME
DEBUG [conftest.py create_test_tables - SYNC]: Table 'people_roles' not found.
DEBUG [conftest.py create_test_tables - SYNC]: Schema for table 'role_permissions':
  SYNC Column: role_id, Type: CHAR(32)
  SYNC Column: permission_id, Type: CHAR(32)
DEBUG [conftest.py create_test_tables - SYNC]: Schema for table 'applications':
  SYNC Column: id, Type: CHAR(32)
  SYNC Column: name, Type: VARCHAR(255)
  SYNC Column: description, Type: TEXT
  SYNC Column: type, Type: VARCHAR(5)
    SYNC 'applications.type' column found. Type: VARCHAR(5)
  SYNC Column: hostedOn, Type: VARCHAR(255)
  SYNC Column: workarounds, Type: TEXT
  SYNC Column: derivedRTO, Type: VARCHAR(50)
  SYNC Column: status, Type: VARCHAR(8)
  SYNC Column: organizationId, Type: CHAR(32)
  SYNC Column: appOwnerId, Type: CHAR(32)
DEBUG [conftest.py create_test_tables_async]: Creating async tables...
DEBUG [conftest.py create_test_tables_async]: Async tables created.
DEBUG [conftest.py async_db_session]: Added default async organization: Default Test Organization Async
DEBUG [conftest.py async_db_session]: Added default async user: default.async.user@example.com
DEBUG [conftest.py async_db_session]: Committed default async org/user for session 4449509968.
EEDEBUG [conftest.py async_db_session]: Committed default async org/user for session 4450048080.
EDEBUG [conftest.py async_db_session]: Committed default async org/user for session 4449879472.
EEEEEEEEEDEBUG [conftest.py async_db_session]: Committed default async org/user for session 4450178048.
EEDEBUG [conftest.py async_db_session]: Committed default async org/user for session 4450169904.
FDEBUG [conftest.py async_db_session]: Committed default async org/user for session 4450645856.
FFDEBUG [conftest.py create_test_tables_async]: Dropping async tables...
DEBUG [conftest.py create_test_tables_async]: Async tables dropped.
DEBUG [conftest.py create_test_tables]: All tables dropped.


==================================== ERRORS ====================================
__________________ ERROR at setup of test_create_application ___________________
file /Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/backend/app/tests/api/test_applications_api.py, line 78
  @pytest.mark.asyncio
  async def test_create_application(authenticated_test_client: AsyncClient, async_db_session: AsyncSession, current_test_user: UserModel):
      # current_test_user is assumed to be from the authenticated_test_client's token
      # The application's organization will be derived from this user.
      org_id_from_auth_user = current_test_user.organization_id

      # Create an app_owner in the same organization as the authenticated user
      app_owner = await create_test_user_async(async_db_session, organization_id=org_id_from_auth_user, first_name_prefix="AppOwnerFull")

      application_data = ApplicationCreate(
          name="My New Critical App",
          description="A very important application for testing purposes.",
          app_owner_id=app_owner.id, # Use the ID of the created user
          type=ApplicationType.OWNED.value,
          organization_id=str(org_id_from_auth_user),
          is_active=True,
          hosted_on="Cloud Provider X",
          workarounds="Use manual process as a workaround."
      )

      response = await authenticated_test_client.post("/api/v1/applications/", json=application_data.model_dump(mode='json'))

      assert response.status_code == 201, response.text
      data = response.json()
      assert data["name"] == application_data.name
      assert data["description"] == application_data.description
      assert data["organization"]["id"] == str(org_id_from_auth_user)
      assert data["app_owner"]["id"] == str(app_owner.id)
      assert data["type"] == application_data.type.value # Enum value
      assert data["hosted_on"] == application_data.hosted_on
      assert data["workarounds"] == application_data.workarounds
      assert data["is_active"] is True
      assert "id" in data
      assert "created_at" in data
      assert "updated_at" in data
      assert data["organization"]["name"] is not None # Assuming OrganizationResponse has name
      assert data["app_owner"]["email"] == app_owner.email # Assuming UserResponse has email
E       fixture 'current_test_user' not found
>       available fixtures: _class_event_loop, _function_event_loop, _module_event_loop, _package_event_loop, _session_event_loop, anyio_backend, anyio_backend_name, anyio_backend_options, async_current_test_user, async_db_session, async_engine_fixture, authenticated_test_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, create_test_tables, create_test_tables_async, db_session, doctest_namespace, event_loop, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, monkeypatch, override_get_async_db, override_get_db, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, test_client, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/backend/app/tests/api/test_applications_api.py:78
____________ ERROR at setup of test_create_application_minimal_data ____________
file /Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/backend/app/tests/api/test_applications_api.py, line 116
  @pytest.mark.asyncio
  async def test_create_application_minimal_data(authenticated_test_client: AsyncClient, current_test_user: UserModel):
      # The application's organization will be derived from current_test_user.
      org_id_from_auth_user = current_test_user.organization_id

      application_data = ApplicationCreate(
          name="Minimal App For Test",
          type=ApplicationType.SAAS.value, # Software as a Service
          organization_id=str(org_id_from_auth_user),
          is_active=True
          # No app_owner_id, description, hosted_on, workarounds
      )
      response = await authenticated_test_client.post("/api/v1/applications/", json=application_data.model_dump(mode='json'))
      assert response.status_code == 201, response.text
      data = response.json()
      assert data["name"] == application_data.name
      assert data["organization"]["id"] == str(org_id_from_auth_user)
      assert data["type"] == application_data.type.value
      assert data["is_active"] is True
      assert data["app_owner_id"] is None
      assert data["app_owner"] is None
      assert data["description"] is None
      assert data["hosted_on"] is None
      assert data["workarounds"] is None
E       fixture 'current_test_user' not found
>       available fixtures: _class_event_loop, _function_event_loop, _module_event_loop, _package_event_loop, _session_event_loop, anyio_backend, anyio_backend_name, anyio_backend_options, async_current_test_user, async_db_session, async_engine_fixture, authenticated_test_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, create_test_tables, create_test_tables_async, db_session, doctest_namespace, event_loop, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, monkeypatch, override_get_async_db, override_get_db, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, test_client, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/backend/app/tests/api/test_applications_api.py:116
________ ERROR at setup of test_create_application_invalid_app_owner_id ________
file /Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/backend/app/tests/api/test_applications_api.py, line 141
  @pytest.mark.asyncio
  async def test_create_application_invalid_app_owner_id(authenticated_test_client: AsyncClient, async_db_session: AsyncSession, current_test_user: UserModel):
      # current_test_user.organization_id will be the app's organization
      # Create a different organization for the invalid app owner
      org_other = await create_test_organization_async(async_db_session, name="Other Org For Invalid Owner")
      app_owner_other_org = await create_test_user_async(async_db_session, organization_id=org_other.id, first_name_prefix="OtherOrgOwner")

      application_data = ApplicationCreate(
          name="App With Cross-Org Owner",
          type=ApplicationType.OWNED.value, # Commercial Off-The-Shelf
          organization_id=str(current_test_user.organization_id),
          is_active=True,
          app_owner_id=app_owner_other_org.id # Owner from a different org
      )

      response = await authenticated_test_client.post("/api/v1/applications/", json=application_data.model_dump(mode='json'))

      assert response.status_code == 422, response.text
      assert "App owner must belong to the same organization as the application" in response.json()["detail"]
E       fixture 'current_test_user' not found
>       available fixtures: _class_event_loop, _function_event_loop, _module_event_loop, _package_event_loop, _session_event_loop, anyio_backend, anyio_backend_name, anyio_backend_options, async_current_test_user, async_db_session, async_engine_fixture, authenticated_test_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, create_test_tables, create_test_tables_async, db_session, doctest_namespace, event_loop, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, monkeypatch, override_get_async_db, override_get_db, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, test_client, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/backend/app/tests/api/test_applications_api.py:141
___________ ERROR at setup of test_create_application_duplicate_name ___________
file /Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/backend/app/tests/api/test_applications_api.py, line 161
  @pytest.mark.asyncio
  async def test_create_application_duplicate_name(authenticated_test_client: AsyncClient, async_db_session: AsyncSession, current_test_user: UserModel):
      # The application's organization will be derived from current_test_user.
      app_owner_same_org = await create_test_user_async(async_db_session, organization_id=current_test_user.organization_id, first_name_prefix="DuplicateNameOwner")

      app_name = f"Unique App Name {uuid.uuid4()}"

      application_data_1 = ApplicationCreate(
          name=app_name,
          type=ApplicationType.OWNED.value,
          organization_id=str(current_test_user.organization_id),
          is_active=True,
          app_owner_id=app_owner_same_org.id
      )
      response1 = await authenticated_test_client.post("/api/v1/applications/", json=application_data_1.model_dump(mode='json'))
      assert response1.status_code == 201, response1.text

      # Attempt to create another application with the same name in the same organization
      application_data_2 = ApplicationCreate(
          name=app_name, # Same name
          type=ApplicationType.OWNED.value, # Different type, but name should be unique
          organization_id=str(current_test_user.organization_id),
          is_active=True,
          app_owner_id=app_owner_same_org.id
      )
      response2 = await authenticated_test_client.post("/api/v1/applications/", json=application_data_2.model_dump(mode='json'))

      assert response2.status_code == 422, response2.text # Or 400 depending on specific backend validation
      assert f"Application with name '{app_name}' already exists in this organization" in response2.json()["detail"]
E       fixture 'current_test_user' not found
>       available fixtures: _class_event_loop, _function_event_loop, _module_event_loop, _package_event_loop, _session_event_loop, anyio_backend, anyio_backend_name, anyio_backend_options, async_current_test_user, async_db_session, async_engine_fixture, authenticated_test_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, create_test_tables, create_test_tables_async, db_session, doctest_namespace, event_loop, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, monkeypatch, override_get_async_db, override_get_db, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, test_client, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/backend/app/tests/api/test_applications_api.py:161
___________________ ERROR at setup of test_read_application ____________________
file /Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/backend/app/tests/api/test_applications_api.py, line 191
  @pytest.mark.asyncio
  async def test_read_application(authenticated_test_client: AsyncClient, db_session: Session, current_test_user: UserModel):
      org_id_current_user = current_test_user.organization_id
      app_owner = create_test_user(db_session, organization_id=org_id_current_user, first_name_prefix="ReadableAppOwner")

      application_create_data = ApplicationCreate(
          name="My Readable App",
          description="Description for readable app.",
          app_owner_id=app_owner.id,
          type=ApplicationType.OWNED.value,
          organization_id=str(org_id_current_user),
          is_active=True,
          hosted_on="On-Premise"
      )

      create_response = await authenticated_test_client.post("/api/v1/applications/", json=application_create_data.model_dump(mode='json'))
      assert create_response.status_code == 201, create_response.text
      created_app_data = create_response.json()
      created_app_id = created_app_data["id"]

      # Test reading the created application
      response = await authenticated_test_client.get(f"/api/v1/applications/{created_app_id}")
      assert response.status_code == 200, response.text
      data = response.json()
      assert data["id"] == created_app_id
      assert data["name"] == application_create_data.name
      assert data["description"] == application_create_data.description
      assert data["organization"]["id"] == str(org_id_current_user)
      assert data["app_owner"]["id"] == str(app_owner.id)
      assert data["app_owner"]["email"] == app_owner.email
      assert data["type"] == application_create_data.type
      assert data["hosted_on"] == application_create_data.hosted_on
      assert data["is_active"] is True

      # Test: User cannot read application from another organization
      org_other = create_test_organization(db_session, name="Other Org For Read Test")
      app_owner_other_org = create_test_user(db_session, organization_id=org_other.id, first_name_prefix="OtherOrgAppOwner")

      # Create application in other_org directly (not via API of current_test_user)
      # For simplicity, we'll assume a direct DB entry or a separate mechanism would create this.
      # Here, we'll simulate its creation for the purpose of getting an ID.
      # In a real scenario, this might involve another authenticated client or service call.
      from backend.app.services.application_service import ApplicationService # Temp import
      from backend.app.models.application import Application # Temp import
      app_service = ApplicationService(db_session) # type: ignore
      other_app_obj = Application(
          name="Cross Org App",
          organization_id=org_other.id,
          app_owner_id=app_owner_other_org.id,
          type=ApplicationType.OWNED.value,
          creator_id=app_owner_other_org.id # Placeholder, as service layer handles this
      )
      db_session.add(other_app_obj)
      db_session.commit()
      db_session.refresh(other_app_obj)
      other_app_id = other_app_obj.id

      response_other_org_app = await authenticated_test_client.get(f"/api/v1/applications/{other_app_id}")
      assert response_other_org_app.status_code == 404, response_other_org_app.text
      assert response_other_org_app.json()["detail"] == "Application not found"
E       fixture 'current_test_user' not found
>       available fixtures: _class_event_loop, _function_event_loop, _module_event_loop, _package_event_loop, _session_event_loop, anyio_backend, anyio_backend_name, anyio_backend_options, async_current_test_user, async_db_session, async_engine_fixture, authenticated_test_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, create_test_tables, create_test_tables_async, db_session, doctest_namespace, event_loop, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, monkeypatch, override_get_async_db, override_get_db, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, test_client, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/backend/app/tests/api/test_applications_api.py:191
______________ ERROR at setup of test_read_application_not_found _______________
file /Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/backend/app/tests/api/test_applications_api.py, line 252
  @pytest.mark.asyncio
  async def test_read_application_not_found(authenticated_test_client: AsyncClient, db_session: Session, current_test_user: UserModel): # Added current_test_user for consistency
      non_existent_app_id = uuid.uuid4()
      response = await authenticated_test_client.get(f"/api/v1/applications/{non_existent_app_id}")
      assert response.status_code == 404, response.text
      assert response.json()["detail"] == "Application not found"
E       fixture 'current_test_user' not found
>       available fixtures: _class_event_loop, _function_event_loop, _module_event_loop, _package_event_loop, _session_event_loop, anyio_backend, anyio_backend_name, anyio_backend_options, async_current_test_user, async_db_session, async_engine_fixture, authenticated_test_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, create_test_tables, create_test_tables_async, db_session, doctest_namespace, event_loop, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, monkeypatch, override_get_async_db, override_get_db, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, test_client, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/backend/app/tests/api/test_applications_api.py:252
________________ ERROR at setup of test_read_applications_empty ________________
file /Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/backend/app/tests/api/test_applications_api.py, line 259
  @pytest.mark.asyncio
  async def test_read_applications_empty(authenticated_test_client: AsyncClient, current_test_user: UserModel): # Added current_test_user
      # This test assumes that for the current_test_user's organization, no applications exist yet.
      # If other tests create apps for this org without cleaning up, this test might be flaky.
      # Consider adding cleanup or ensuring a fresh org for this test if needed.
      response = await authenticated_test_client.get("/api/v1/applications/")
      assert response.status_code == 200, response.text
      paginated_response = response.json()
      assert paginated_response["items"] == []
      assert paginated_response["total"] == 0
      assert paginated_response["page"] == 1
      assert paginated_response["size"] is not None # Default size or passed param
E       fixture 'current_test_user' not found
>       available fixtures: _class_event_loop, _function_event_loop, _module_event_loop, _package_event_loop, _session_event_loop, anyio_backend, anyio_backend_name, anyio_backend_options, async_current_test_user, async_db_session, async_engine_fixture, authenticated_test_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, create_test_tables, create_test_tables_async, db_session, doctest_namespace, event_loop, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, monkeypatch, override_get_async_db, override_get_db, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, test_client, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/backend/app/tests/api/test_applications_api.py:259
________________ ERROR at setup of test_read_applications_list _________________
file /Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/backend/app/tests/api/test_applications_api.py, line 272
  @pytest.mark.asyncio
  async def test_read_applications_list(authenticated_test_client: AsyncClient, db_session: Session, current_test_user: UserModel):
      org_id_current_user = current_test_user.organization_id
      app_owner1 = create_test_user(db_session, organization_id=org_id_current_user, first_name_prefix="ListAppOwner1")
      app_owner2 = create_test_user(db_session, organization_id=org_id_current_user, first_name_prefix="ListAppOwner2")

      app1_create_data = ApplicationCreate(
          name="Listed App Alpha",
          type=ApplicationType.OWNED.value,
          organization_id=str(org_id_current_user),
          is_active=True,
          app_owner_id=app_owner1.id
      )
      app2_create_data = ApplicationCreate(
          name="Listed App Beta",
          type=ApplicationType.OWNED.value,
          organization_id=str(org_id_current_user),
          is_active=True,
          app_owner_id=app_owner2.id,
          description="Beta version"
      )

      # Create two applications in the current user's organization
      response_create1 = await authenticated_test_client.post("/api/v1/applications/", json=app1_create_data.model_dump(mode='json'))
      assert response_create1.status_code == 201, response_create1.text
      app1_id = response_create1.json()["id"]

      response_create2 = await authenticated_test_client.post("/api/v1/applications/", json=app2_create_data.model_dump(mode='json'))
      assert response_create2.status_code == 201, response_create2.text
      app2_id = response_create2.json()["id"]

      # Create an application in a different organization (should not be listed)
      org_other = create_test_organization(db_session, name="Other Org For List Test")
      app_owner_other_org = create_test_user(db_session, organization_id=org_other.id, first_name_prefix="OtherOrgListOwner")

      # Using service directly to create app in another org to avoid complex auth setup for this test part
      from backend.app.services.application_service import ApplicationService # Temp import
      from backend.app.models.application import Application # Temp import
      app_service = ApplicationService(db_session) # type: ignore
      other_org_app_obj = Application(
          name="Cross Org App For List",
          organization_id=org_other.id,
          app_owner_id=app_owner_other_org.id,
          type=ApplicationType.OWNED.value,
          creator_id=app_owner_other_org.id # Placeholder
      )
      db_session.add(other_org_app_obj)
      db_session.commit()

      # List applications for the current user's organization
      response_list = await authenticated_test_client.get("/api/v1/applications/")
      assert response_list.status_code == 200, response_list.text
      paginated_response = response_list.json()

      assert paginated_response["total"] == 2
      assert len(paginated_response["items"]) == 2

      listed_app_ids = {item["id"] for item in paginated_response["items"]}
      assert app1_id in listed_app_ids
      assert app2_id in listed_app_ids

      for item in paginated_response["items"]:
          assert item["organization"]["id"] == str(org_id_current_user)
          assert item["is_active"] is True
          if item["id"] == app1_id:
              assert item["name"] == app1_create_data.name
              assert item["app_owner"]["id"] == str(app_owner1.id)
          elif item["id"] == app2_id:
              assert item["name"] == app2_create_data.name
              assert item["app_owner"]["id"] == str(app_owner2.id)
E       fixture 'current_test_user' not found
>       available fixtures: _class_event_loop, _function_event_loop, _module_event_loop, _package_event_loop, _session_event_loop, anyio_backend, anyio_backend_name, anyio_backend_options, async_current_test_user, async_db_session, async_engine_fixture, authenticated_test_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, create_test_tables, create_test_tables_async, db_session, doctest_namespace, event_loop, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, monkeypatch, override_get_async_db, override_get_db, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, test_client, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/backend/app/tests/api/test_applications_api.py:272
______ ERROR at setup of test_read_applications_pagination_and_filtering _______
file /Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/backend/app/tests/api/test_applications_api.py, line 343
  @pytest.mark.asyncio
  async def test_read_applications_pagination_and_filtering(authenticated_test_client: AsyncClient, db_session: Session, current_test_user: UserModel):
      org_id = current_test_user.organization_id
      # Helper to create apps for this test via API
      async def _create_app(name: str, app_type: ApplicationType, description: str = "Test app"):
          app_owner = create_test_user(db_session, organization_id=org_id, first_name_prefix=f"Owner{name.replace(' ', '')}")
          payload = ApplicationCreate(name=name, type=app_type, organization_id=str(org_id), app_owner_id=app_owner.id, description=description, is_active=True)
          response = await authenticated_test_client.post("/api/v1/applications/", json=payload.model_dump(mode='json'))
          assert response.status_code == 201, f"Failed to create {name}: {response.text}"
          return response.json()

      # Create a set of applications
      app_configs = [
          {"name": "Alpha App", "type": ApplicationType.OWNED.value, "desc": "Alpha custom app"},
          {"name": "Bravo App", "type": ApplicationType.SAAS.value, "desc": "Bravo SaaS solution"},
          {"name": "Charlie App", "type": ApplicationType.OWNED.value, "desc": "Charlie custom app"},
          {"name": "Delta App", "type": ApplicationType.OWNED.value, "desc": "Delta COTS package"},
          {"name": "Echo App", "type": ApplicationType.SAAS.value, "desc": "Echo SaaS platform"},
          {"name": "Foxtrot App Special", "type": ApplicationType.OWNED.value, "desc": "Foxtrot special project"}
      ]
      created_apps = []
      for config in app_configs:
          app_data = await _create_app(config["name"], config["type"], config["desc"])
          created_apps.append(app_data)

      # --- Pagination Tests ---
      # Assuming default order is by creation time (or ID which is sequential in tests)
      # Test 1: page=1, size=2 (expecting first 2 created: Alpha, Bravo)
      response_page1_size2 = await authenticated_test_client.get("/api/v1/applications/?page=1&size=2")
      assert response_page1_size2.status_code == 200, response_page1_size2.text
      data_p1s2 = response_page1_size2.json()
      assert data_p1s2["total"] == 6
      assert data_p1s2["page"] == 1
      assert data_p1s2["size"] == 2
      assert data_p1s2["pages"] == 3
      assert len(data_p1s2["items"]) == 2
      assert data_p1s2["items"][0]["name"] == "Alpha App"
      assert data_p1s2["items"][1]["name"] == "Bravo App"

      # Test 2: page=2, size=2 (expecting next 2: Charlie, Delta)
      response_page2_size2 = await authenticated_test_client.get("/api/v1/applications/?page=2&size=2")
      assert response_page2_size2.status_code == 200, response_page2_size2.text
      data_p2s2 = response_page2_size2.json()
      assert len(data_p2s2["items"]) == 2
      assert data_p2s2["items"][0]["name"] == "Charlie App"
      assert data_p2s2["items"][1]["name"] == "Delta App"

      # Test 3: page=3, size=2 (expecting next 2: Echo, Foxtrot)
      response_page3_size2 = await authenticated_test_client.get("/api/v1/applications/?page=3&size=2")
      assert response_page3_size2.status_code == 200, response_page3_size2.text
      data_p3s2 = response_page3_size2.json()
      assert len(data_p3s2["items"]) == 2 # Corrected: 6 apps, page 3 size 2 should have last 2
      assert data_p3s2["items"][0]["name"] == "Echo App"
      assert data_p3s2["items"][1]["name"] == "Foxtrot App Special"

      # --- Name Filtering Tests ---
      # Test 1: name contains "App" (partial match, case-insensitive if backend supports)
      # Assuming backend does case-sensitive exact or prefix match for simplicity here if not specified
      response_name_app = await authenticated_test_client.get("/api/v1/applications/?name=App") # This might be too broad or specific depending on backend
      # For a more robust test, let's filter by a more specific prefix
      response_name_alpha = await authenticated_test_client.get("/api/v1/applications/?name=Alpha App")
      assert response_name_alpha.status_code == 200
      data_name_alpha = response_name_alpha.json()
      assert data_name_alpha["total"] == 1
      assert len(data_name_alpha["items"]) == 1
      assert data_name_alpha["items"][0]["name"] == "Alpha App"

      response_name_special = await authenticated_test_client.get("/api/v1/applications/?name=Special") # Test partial name from Foxtrot App Special
      assert response_name_special.status_code == 200
      data_name_special = response_name_special.json()
      # This assertion depends on whether 'name' filter is 'contains' or 'startswith'
      # Assuming 'contains' for this example, adjust if service layer is different
      assert data_name_special["total"] == 1
      assert data_name_special["items"][0]["name"] == "Foxtrot App Special"

      # --- Application Type Filtering Tests ---
      # Filter by SAAS
      response_type_saas = await authenticated_test_client.get(f"/api/v1/applications/?application_type={ApplicationType.SAAS.value}")
      assert response_type_saas.status_code == 200
      data_type_saas = response_type_saas.json()
      assert data_type_saas["total"] == 2 # Bravo, Echo
      assert len(data_type_saas["items"]) == 2
      saas_names = {item["name"] for item in data_type_saas["items"]}
      assert "Bravo App" in saas_names
      assert "Echo App" in saas_names

      # Filter by OWNED
      response_type_owned = await authenticated_test_client.get(f"/api/v1/applications/?application_type={ApplicationType.OWNED.value}")
      assert response_type_owned.status_code == 200
      data_type_owned = response_type_owned.json()
      assert data_type_owned["total"] == 4 # Alpha, Charlie, Delta, Foxtrot
      assert len(data_type_owned["items"]) == 4
      owned_names = {item["name"] for item in data_type_owned["items"]}
      assert "Alpha App" in owned_names
      assert "Charlie App" in owned_names
      assert "Delta App" in owned_names
      assert "Foxtrot App Special" in owned_names

      # --- Combined Filtering and Pagination ---
      # Filter by OWNED, page 1, size 2. Expect Alpha, Charlie (4 total OWNED apps)
      response_combo = await authenticated_test_client.get(f"/api/v1/applications/?application_type={ApplicationType.OWNED.value}&page=1&size=2")
      assert response_combo.status_code == 200
      data_combo = response_combo.json()
      assert data_combo["total"] == 4 # Alpha, Charlie, Delta, Foxtrot
      assert data_combo["page"] == 1
      assert data_combo["size"] == 2
      assert data_combo["pages"] == 2 # 4 items, size 2 means 2 pages
      assert len(data_combo["items"]) == 2
      assert data_combo["items"][0]["name"] == "Alpha App"
      assert data_combo["items"][1]["name"] == "Charlie App"

      # Verify all returned items belong to the correct organization and are active
      all_responses = [data_p1s2, data_p2s2, data_p3s2, data_name_alpha, data_name_special, data_type_saas, data_type_owned, data_combo]
      for resp_data in all_responses:
          for item in resp_data["items"]:
              assert item["organization"]["id"] == str(org_id)
              assert item["is_active"] is True
E       fixture 'current_test_user' not found
>       available fixtures: _class_event_loop, _function_event_loop, _module_event_loop, _package_event_loop, _session_event_loop, anyio_backend, anyio_backend_name, anyio_backend_options, async_current_test_user, async_db_session, async_engine_fixture, authenticated_test_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, create_test_tables, create_test_tables_async, db_session, doctest_namespace, event_loop, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, monkeypatch, override_get_async_db, override_get_db, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, test_client, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/backend/app/tests/api/test_applications_api.py:343
__________________ ERROR at setup of test_update_application ___________________
file /Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/backend/app/tests/api/test_applications_api.py, line 461
  @pytest.mark.asyncio
  async def test_update_application(authenticated_test_client: AsyncClient, db_session: AsyncSession, current_test_user: UserModel):
      org_id = current_test_user.organization_id
      owner_orig = create_test_user(db_session, organization_id=org_id, first_name_prefix="OwnerOrigUpd")
      owner_new = create_test_user(db_session, organization_id=org_id, first_name_prefix="OwnerNewUpd")

      app_create_payload = ApplicationCreate(
          name="Original App Name",
          type=ApplicationType.OWNED.value,
          organization_id=str(org_id),
          is_active=True,
          app_owner_id=owner_orig.id,
          description="Original Description",
          criticality="Medium",
          status="ACTIVE" # Assuming status is a simple string, or use ApplicationStatusEnum.ACTIVE.value
      )
      create_response = await authenticated_test_client.post("/api/v1/applications/", json=app_create_payload.model_dump(mode='json'))
      assert create_response.status_code == 201, create_response.text
      created_app_data = create_response.json()
      created_app_id = created_app_data["id"]

      update_payload = ApplicationUpdate(
          name="Updated App Name",
          description="Updated Description",
          app_owner_id=owner_new.id,
          type=ApplicationType.OWNED.value,
          criticality="High",
          status="MAINTENANCE" # Assuming status is a simple string, or use ApplicationStatusEnum.MAINTENANCE.value
      )
      response = await authenticated_test_client.put(f"/api/v1/applications/{created_app_id}", json=update_payload.model_dump(mode='json', exclude_unset=True))
      assert response.status_code == 200, response.text
      updated_data = response.json()

      assert updated_data["id"] == created_app_id
      assert updated_data["name"] == update_payload.name
      assert updated_data["description"] == update_payload.description
      assert updated_data["app_owner"]["id"] == str(owner_new.id)
      assert updated_data["type"] == ApplicationType.OWNED.value
      assert updated_data["criticality"] == update_payload.criticality
      assert updated_data["status"] == "MAINTENANCE"
      assert updated_data["organization"]["id"] == str(org_id)
      assert updated_data["is_active"] is True
E       fixture 'current_test_user' not found
>       available fixtures: _class_event_loop, _function_event_loop, _module_event_loop, _package_event_loop, _session_event_loop, anyio_backend, anyio_backend_name, anyio_backend_options, async_current_test_user, async_db_session, async_engine_fixture, authenticated_test_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, create_test_tables, create_test_tables_async, db_session, doctest_namespace, event_loop, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, monkeypatch, override_get_async_db, override_get_db, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, test_client, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/backend/app/tests/api/test_applications_api.py:461
_____________ ERROR at setup of test_update_application_not_found ______________
file /Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/backend/app/tests/api/test_applications_api.py, line 504
  @pytest.mark.asyncio
  async def test_update_application_not_found(authenticated_test_client: AsyncClient, current_test_user: UserModel):
      non_existent_app_id = uuid.uuid4()
      update_payload = ApplicationUpdate(name="Attempted Update To NonExistent")
      response = await authenticated_test_client.put(f"/api/v1/applications/{non_existent_app_id}", json=update_payload.model_dump(mode='json', exclude_unset=True))
      assert response.status_code == 404, response.text
      assert response.json()["detail"] == "Application not found"
E       fixture 'current_test_user' not found
>       available fixtures: _class_event_loop, _function_event_loop, _module_event_loop, _package_event_loop, _session_event_loop, anyio_backend, anyio_backend_name, anyio_backend_options, async_current_test_user, async_db_session, async_engine_fixture, authenticated_test_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, create_test_tables, create_test_tables_async, db_session, doctest_namespace, event_loop, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, monkeypatch, override_get_async_db, override_get_db, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, test_client, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/backend/app/tests/api/test_applications_api.py:504
___________ ERROR at setup of test_update_application_invalid_owner ____________
file /Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/backend/app/tests/api/test_applications_api.py, line 512
  @pytest.mark.asyncio
  async def test_update_application_invalid_owner(authenticated_test_client: AsyncClient, db_session: AsyncSession, current_test_user: UserModel):
      org_id = current_test_user.organization_id
      initial_owner = create_test_user(db_session, organization_id=org_id, first_name_prefix="InitialAppOwner")

      app_create_payload = ApplicationCreate(
          name="App For Invalid Owner Update Test",
          type=ApplicationType.OWNED.value,
          organization_id=str(org_id),
          is_active=True,
          app_owner_id=initial_owner.id,
          status="ACTIVE"
      )
      create_response = await authenticated_test_client.post("/api/v1/applications/", json=app_create_payload.model_dump(mode='json'))
      assert create_response.status_code == 201, create_response.text
      created_app_id = create_response.json()["id"]

      # Scenario 1: Non-existent App Owner ID
      non_existent_owner_id = uuid.uuid4()
      update_payload_non_existent_owner = ApplicationUpdate(app_owner_id=non_existent_owner_id)
      response_non_existent = await authenticated_test_client.put(
          f"/api/v1/applications/{created_app_id}",
          json=update_payload_non_existent_owner.model_dump(mode='json', exclude_unset=True)
      )
      assert response_non_existent.status_code == 422, response_non_existent.text
      # Assuming the service layer checks for user existence and raises an appropriate error.
      # The exact message might vary based on ApplicationService implementation.
      assert f"App owner with id {str(non_existent_owner_id)} not found" in response_non_existent.json()["detail"]

      # Scenario 2: App Owner from a different organization
      other_org = create_test_organization(db_session, name="Other Org For Invalid Owner Test")
      other_org_owner = create_test_user(db_session, organization_id=other_org.id, first_name_prefix="OtherOrgAppOwner")

      update_payload_cross_org_owner = ApplicationUpdate(app_owner_id=other_org_owner.id)
      response_cross_org = await authenticated_test_client.put(
          f"/api/v1/applications/{created_app_id}",
          json=update_payload_cross_org_owner.model_dump(mode='json', exclude_unset=True)
      )
      assert response_cross_org.status_code == 422, response_cross_org.text
      assert "App owner must belong to the same organization as the application." in response_cross_org.json()["detail"]
E       fixture 'current_test_user' not found
>       available fixtures: _class_event_loop, _function_event_loop, _module_event_loop, _package_event_loop, _session_event_loop, anyio_backend, anyio_backend_name, anyio_backend_options, async_current_test_user, async_db_session, async_engine_fixture, authenticated_test_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, create_test_tables, create_test_tables_async, db_session, doctest_namespace, event_loop, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, monkeypatch, override_get_async_db, override_get_db, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, test_client, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/backend/app/tests/api/test_applications_api.py:512
__________________ ERROR at setup of test_delete_application ___________________
file /Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/backend/app/tests/api/test_applications_api.py, line 553
  @pytest.mark.asyncio
  async def test_delete_application(authenticated_test_client: AsyncClient, async_db_session: AsyncSession, current_test_user: UserModel):
      org_id = current_test_user.organization_id
      app_owner = await create_test_user_async(async_db_session, organization_id=org_id, first_name_prefix="AppOwnerForDelete")

      app_create_payload = ApplicationCreate(
          name="App To Be Soft Deleted",
          type=ApplicationType.OWNED.value,
          organization_id=str(org_id),
          is_active=True,
          app_owner_id=app_owner.id,
          status="ACTIVE"
      )
      create_response = await authenticated_test_client.post("/api/v1/applications/", json=app_create_payload.model_dump(mode='json'))
      assert create_response.status_code == 201, create_response.text
      created_app_data = create_response.json()
      created_app_id = created_app_data["id"]

      # Soft delete the application
      delete_response = await authenticated_test_client.delete(f"/api/v1/applications/{created_app_id}")
      assert delete_response.status_code == 200, delete_response.text
      deleted_app_data = delete_response.json()

      assert deleted_app_data["id"] == created_app_id
      assert deleted_app_data["name"] == app_create_payload.name
      assert deleted_app_data["is_active"] is False
      assert deleted_app_data["deleted_at"] is not None
      assert deleted_app_data["organization"]["id"] == str(org_id)
      assert deleted_app_data["app_owner"]["id"] == str(app_owner.id)

      # Verify the application is not retrievable via GET by ID after soft delete
      get_response_after_delete = await authenticated_test_client.get(f"/api/v1/applications/{created_app_id}")
      assert get_response_after_delete.status_code == 404, get_response_after_delete.text
      assert get_response_after_delete.json()["detail"] == "Application not found"

      # Verify the application is not listed in active applications
      list_response = await authenticated_test_client.get("/api/v1/applications/")
      assert list_response.status_code == 200
      listed_apps = list_response.json()["items"]
      assert not any(app["id"] == created_app_id for app in listed_apps)
E       fixture 'current_test_user' not found
>       available fixtures: _class_event_loop, _function_event_loop, _module_event_loop, _package_event_loop, _session_event_loop, anyio_backend, anyio_backend_name, anyio_backend_options, async_current_test_user, async_db_session, async_engine_fixture, authenticated_test_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, create_test_tables, create_test_tables_async, db_session, doctest_namespace, event_loop, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, monkeypatch, override_get_async_db, override_get_db, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, test_client, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/backend/app/tests/api/test_applications_api.py:553
_____________ ERROR at setup of test_delete_application_not_found ______________
file /Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/backend/app/tests/api/test_applications_api.py, line 594
  @pytest.mark.asyncio
  async def test_delete_application_not_found(authenticated_test_client: AsyncClient, current_test_user: UserModel):
      non_existent_app_id = uuid.uuid4()
      response = await authenticated_test_client.delete(f"/api/v1/applications/{non_existent_app_id}")
      assert response.status_code == 404, response.text
      assert response.json()["detail"] == "Application not found"
E       fixture 'current_test_user' not found
>       available fixtures: _class_event_loop, _function_event_loop, _module_event_loop, _package_event_loop, _session_event_loop, anyio_backend, anyio_backend_name, anyio_backend_options, async_current_test_user, async_db_session, async_engine_fixture, authenticated_test_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, create_test_tables, create_test_tables_async, db_session, doctest_namespace, event_loop, event_loop_policy, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, monkeypatch, override_get_async_db, override_get_db, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, test_client, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory
>       use 'pytest --fixtures [testpath]' for help on them.

/Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/backend/app/tests/api/test_applications_api.py:594
=================================== FAILURES ===================================
_______________ test_update_application_cross_organization_fail ________________

authenticated_test_client = <httpx.AsyncClient object at 0x1093fa2b0>
async_db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x109403430>
async_current_test_user = <User(id=00000000-0000-0000-0000-000000000002, email='default.async.user@example.com')>

    @pytest.mark.asyncio
    async def test_update_application_cross_organization_fail(
        authenticated_test_client: AsyncClient,
        async_db_session: AsyncSession,
        async_current_test_user: UserModel
    ):
        # Create an organization different from the current_test_user's organization
        other_org = await create_test_organization_async(async_db_session, name="Other Org For Cross-Update Test")
        other_org_owner = await create_test_user_async(async_db_session, organization_id=other_org.id, first_name_prefix="OtherOrgOwnerUpdate")
        # No need to commit here as helper functions do it
    
        # Create an application in this 'other_org'
>       cross_org_app_to_update = ApplicationModel(
            id=uuid.uuid4(),
            name="Cross-Org App For Update Test",
            organization_id=other_org.id,
            app_owner_id=other_org_owner.id,
            type=ApplicationType.OWNED.value,
            status="ACTIVE",
            created_by_id=async_current_test_user.id # Use current user for created_by_id
        )

backend/app/tests/api/test_applications_api.py:614: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:4: in __init__
    ???
venv/lib/python3.9/site-packages/sqlalchemy/orm/state.py:572: in _initialize_instance
    manager.dispatch.init_failure(self, args, kwargs)
venv/lib/python3.9/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.9/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Application(id=17ce2336-6b2b-4c73-8113-a6a29dd5daf5, name='Cross-Org App For Update Test', organization_id='89c54896-5278-40e1-a632-5ab0aedeb0fe')>
kwargs = {'app_owner_id': UUID('31cdc7e2-52b6-46d9-95ec-6c2a8346dfe7'), 'created_by_id': UUID('00000000-0000-0000-0000-000000000002'), 'id': UUID('17ce2336-6b2b-4c73-8113-a6a29dd5daf5'), 'name': 'Cross-Org App For Update Test', ...}
cls_ = <class 'backend.app.models.domain.applications.Application'>
k = 'created_by_id'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'created_by_id' is an invalid keyword argument for Application

venv/lib/python3.9/site-packages/sqlalchemy/orm/decl_base.py:2173: TypeError
_______________ test_delete_application_cross_organization_fail ________________

authenticated_test_client = <httpx.AsyncClient object at 0x1093f6d00>
async_db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x109477760>
async_current_test_user = <User(id=00000000-0000-0000-0000-000000000002, email='default.async.user@example.com')>

    @pytest.mark.asyncio
    async def test_delete_application_cross_organization_fail(
        authenticated_test_client: AsyncClient,
        async_db_session: AsyncSession,
        async_current_test_user: UserModel
    ):
        # Create an organization different from the current_test_user's organization
        other_org = await create_test_organization_async(async_db_session, name="Other Org For Cross-Delete Test")
        other_org_owner = await create_test_user_async(async_db_session, organization_id=other_org.id, first_name_prefix="OtherOrgOwnerDelete")
    
        # Create an application in this 'other_org'
>       cross_org_app_to_delete = ApplicationModel(
            id=uuid.uuid4(),
            name="Cross-Org App To Delete Test",
            organization_id=other_org.id,
            app_owner_id=other_org_owner.id,
            type=ApplicationType.OWNED.value,
            status="ACTIVE",
            created_by_id=async_current_test_user.id # Use current user for created_by_id
        )

backend/app/tests/api/test_applications_api.py:649: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:4: in __init__
    ???
venv/lib/python3.9/site-packages/sqlalchemy/orm/state.py:572: in _initialize_instance
    manager.dispatch.init_failure(self, args, kwargs)
venv/lib/python3.9/site-packages/sqlalchemy/util/langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv/lib/python3.9/site-packages/sqlalchemy/orm/state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Application(id=01c0b8ae-99f1-4ead-85fa-48722a382aa8, name='Cross-Org App To Delete Test', organization_id='b033303e-b5d2-4ff9-ae9a-69e807333cfc')>
kwargs = {'app_owner_id': UUID('9f9c7e7a-0dd9-4f89-b191-5d263c7318bc'), 'created_by_id': UUID('00000000-0000-0000-0000-000000000002'), 'id': UUID('01c0b8ae-99f1-4ead-85fa-48722a382aa8'), 'name': 'Cross-Org App To Delete Test', ...}
cls_ = <class 'backend.app.models.domain.applications.Application'>
k = 'created_by_id'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'created_by_id' is an invalid keyword argument for Application

venv/lib/python3.9/site-packages/sqlalchemy/orm/decl_base.py:2173: TypeError
___________________ test_delete_already_deleted_application ____________________

authenticated_test_client = <httpx.AsyncClient object at 0x1093e5b80>
db_session = <sqlalchemy.orm.session.Session object at 0x10934b280>

    @pytest.mark.asyncio
    async def test_delete_already_deleted_application(authenticated_test_client: AsyncClient, db_session: Session):
        org = create_test_organization(db_session, name="AppDeleteTwice Org2")
        org_id = org.id
        if org in db_session: db_session.expunge(org)
    
        app_create_data = ApplicationCreate(name="App To Be Deleted Twice Again", organization_id=str(org_id), type=ApplicationType.SAAS.value, is_active=True)
        create_response = await authenticated_test_client.post("/api/v1/applications/", content=app_create_data.model_dump_json(), headers={"Content-Type": "application/json"})
>       assert create_response.status_code == 201, create_response.text
E       AssertionError: {"detail":"Organization with id 6b9b9063-255f-4c3f-b1e7-5d136d25e993 not found."}
E       assert 404 == 201
E        +  where 404 = <Response [404 Not Found]>.status_code

backend/app/tests/api/test_applications_api.py:677: AssertionError
=============================== warnings summary ===============================
backend/app/tests/api/test_applications_api.py::test_create_application
  /Users/bharats/Library/CloudStorage/OneDrive-CYRAACSERVICESPRIVATELIMITED/Work/Product Management/Replit Projects/BCMS/Windsurf/backend/app/tests/conftest.py:82: RuntimeWarning: coroutine 'create_test_tables_async.<locals>.do_inspect' was never awaited
    await conn.run_sync(do_inspect)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED backend/app/tests/api/test_applications_api.py::test_update_application_cross_organization_fail
FAILED backend/app/tests/api/test_applications_api.py::test_delete_application_cross_organization_fail
FAILED backend/app/tests/api/test_applications_api.py::test_delete_already_deleted_application
ERROR backend/app/tests/api/test_applications_api.py::test_create_application
ERROR backend/app/tests/api/test_applications_api.py::test_create_application_minimal_data
ERROR backend/app/tests/api/test_applications_api.py::test_create_application_invalid_app_owner_id
ERROR backend/app/tests/api/test_applications_api.py::test_create_application_duplicate_name
ERROR backend/app/tests/api/test_applications_api.py::test_read_application
ERROR backend/app/tests/api/test_applications_api.py::test_read_application_not_found
ERROR backend/app/tests/api/test_applications_api.py::test_read_applications_empty
ERROR backend/app/tests/api/test_applications_api.py::test_read_applications_list
ERROR backend/app/tests/api/test_applications_api.py::test_read_applications_pagination_and_filtering
ERROR backend/app/tests/api/test_applications_api.py::test_update_application
ERROR backend/app/tests/api/test_applications_api.py::test_update_application_not_found
ERROR backend/app/tests/api/test_applications_api.py::test_update_application_invalid_owner
ERROR backend/app/tests/api/test_applications_api.py::test_delete_application
ERROR backend/app/tests/api/test_applications_api.py::test_delete_application_not_found
=================== 3 failed, 1 warning, 14 errors in 0.35s ====================
